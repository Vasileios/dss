+++
title = "Sound synthesis techniques"
chapter = true
weight = 60
+++

*** chapter 2

**** Additive synthesis

#+BEGIN_SRC js
/* Sound Synthesis techniques
BA 181902
Objective: create complex sounds using additive synthesis technique
// Additive Synthesis
a+b+c+d
where a to d  can be frequencies or any other object such as a waveform
*/

// firts boot the internal server and open Freqscope and Stethoscope

s = Server.internal;
s.boot
Stethoscope.new
FreqScope.new

//create harmonics of a 440Hz A note  

{SinOsc.ar([440, 880, 880*3/2, 1600*4/3, 2000], 0, [0.6, 0.1, 0.09, 0.08, 0.09])}.play//or .scope

//add frequencies using the Mix Ugen

{Mix.fill(10, {SinOsc.ar(440+460.rand, 0, 0.03)})}.play;

//Add also different waveforms i.e sawtooth waveforms 

{Mix.fill(10, {SinOsc.ar(440+440.rand, 0, 0.03)}, {Saw.ar(440+440.rand, 0.01)})}.play;


// a more complex sound

{Mix.fill(10, {SinOsc.ar(440+640.rand, 0, 0.03)+Saw.ar(440+460.rand, 0.01)}, {Saw.ar(440+880.rand, 0.01)})}.play;


#+END_SRC

**** Physical Modeling

*Digital waveguide synthesis*

#+BEGIN_SRC js

/*
BA102002
Physical Modeling
Digital waveguide synthesis: superposition of 2 waves (right going and left going waves) 
modal synthesis (resonant modes of vibration of acoustic systems)(vibrating systems)
delay line (Using delays and filters to model the propagation of sound wave - geometry of the waveguide)
mass-spring models (signals based on masses and springs)

See more on: JA Laird., 2001. The Physical Modelling of Drums Using Digital Waveguides. University of Bristol
*/

/*
Instruction:
Envelope (sound behaviour - time domain), Impulse (trigger), NoiseGen (texture), CombL (delay line)
*/


///WaveTables
//Create a table with size 512 and the amplitudes which shape the waveform. Use Sine or Chebyshev polynomial function.
 
a = Wavetable.sineFill(512, 1.0/[1, 2, 3, 4, 5, 6]);
a = Wavetable.chebyFill(513, [0, 0, 1]);
a = Wavetable.chebyFill(513, [0.3, -0.8, 1.1]);
a = Wavetable.sineFill(512, [0.5]);

a = a.resamp1(256); 
a = a.as(Signal);
a = a.asWavetable; 
// Server side 
s.boot; 
b = Buffer.loadCollection(s, a); 
x = b.play(loop: true); // ok sounds 
x.free; 

/// more on wavetables
//load a wavetable and open the collection to a SoundFile
w = SoundFile.openRead("~/wavetables/WT01.aif".standardizePath); 


// Create an array to load the data 
a = FloatArray.newClear(w.numFrames); 
w.readData(a); 
w.close; 
a.size; 

// resamp the table to have a pow of 2 (bigger to avoid aliassing) 
// in case of many diff samples choose a bigger pow of 2 
 
a = a.resamp1(256); 

// Convert the array to a Signal 
a = a.as(Signal); 
a.size;  

// Convert it to a Wavetable 
a = a.asWavetable; 
a.size; //wavetable format is signal.size * 2 

// load the collection into a buffer 
 
b = Buffer.loadCollection(s, a); 
//play the buffer and loop
x = b.play(loop: true); 
x.free; 
//use Osc interpolating wavetable oscillator. see also VOsc3 and more on Help->UGens>Generators>Deterministic
//Osc.ar(table, freq, phase, mul, add)
x = { LPF.ar(Osc.ar(b, MouseX.kr(440, 880)), SampleRate.ir/2-1000) }.play; 

s.freqscope 

x.free; 

//see Ball, TBall, Spring Ugens on Help
//TBall
//Example:1 
// mouse x controls switch of level
// mouse y controls gravity
(
{
    var t, sf;
    sf = K2A.ar(MouseX.kr > 0.5) > 0;
    t = TBall.ar(sf, MouseY.kr(0.01, 1.0, 1), 0.01);
    Pan2.ar(Ringz.ar(t * 10, 1200, 0.1), MouseX.kr(-1,1));
}.play;
)


//spring


(
{
    var inforce, outforce, freq, k, d;
    inforce = K2A.ar(MouseButton.kr(0,1,0)) > 0;
    k = MouseY.kr(0.1, 20, 1);
    d = MouseX.kr(0.00001, 0.1, 1);
    outforce = Spring.ar(inforce, k, d);
    freq = outforce * 400 + 500; // modulate frequency with the force
    SinOsc.ar(freq, 0, 0.2)
}.play;
)

#+END_SRC

*Wave shaping*

#+BEGIN_SRC js
/*
BA 182202
Waveshaping examples
Objective: create a wavetable and shape the waveform
*/

s.boot;
//Fill this buffer with a series of Chebyshev polynomials, see more on Help->Buffer
b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])});

(
{
    Shaper.ar(
        b,
        SinOsc.ar(300, 0, Line.kr(0,1,6)+Saw.ar(304, Line.kr(0, 1, 6))),
        0.5
    )
}.scope;
)

b.free;

//another example with sine wave series
//Fill this buffer with a series of sine wave partials using specified frequencies, amplitudes, and initial phases.
b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg([1,0,1,1,0,1])});
//see also sine2 and 3

(
{
    Shaper.ar(
        b,
        SinOsc.ar(300+305.rand, 0, LFNoise2.kr(0+0.15)+Saw.ar(304+30.7.rand, LFNoise2.kr(0.15))),
        0.5
    )
}.scope;
)

b.free;

//another example

b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])});
//check also with other tables. 
//Combine tables
//b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])});
//b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg([1,0,1,1,0,1])});

(
{
    Shaper.ar(
        b,
        SinOsc.ar(300+305.rand, 0, LFNoise2.kr(0+0.15.rand)+Saw.ar(304+307.rand, LFNoise2.kr(0.15.rand)))+PinkNoise.ar(0.1.rand),
        0.5
    )
}.scope;
)

b.free;
#+END_SRC

*Creating textures with wavetables*

#+BEGIN_SRC js

/*
BA 182202
Sound Textures examples
Objective: Experiment with table oscilators to create sound textures
*/

// COsc wavetable example 1:

(
b = Buffer.alloc(s, 512, 1, {| buf | buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])});
{ LPF.ar(COsc.ar(b.bufnum, [200.rand.postln, 1000.rand], 0.7, 0.25)*Saw.ar(440+444.rand, WhiteNoise.kr(0.7)), 4000) }.play;
)


#+END_SRC


**** Modulation synthesis

#+BEGIN_SRC js
/*
Modulation synthesis
Obective: modulate the frequency,the phase and the amplitude of a simple waveform using other waveforms as the modulators
*/

/*From 2009 Collins et al. Modulation Synthesis tutorial
//Use MouseX and MouseY to control the modulation 

//Ring Modulation

A straight multiplication of two signals. 

carrier * modulator
*/

{
//2009 Collins et al.
var carrier, modulator, carrfreq, modfreq;

carrfreq= MouseX.kr(440,5000,'exponential');
modfreq= MouseY.kr(1,5000,'exponential');

carrier= SinOsc.ar(carrfreq,0,0.5);
modulator= SinOsc.ar(modfreq,0,0.5);

carrier*modulator;
}.scope


/*
AM synthesis
The modulation is Unipolar
means always possitive (0, 1)
SinOsc.ar(440, 0, 0.5) (-0.5, 0.5) bipolar
SinOsc.ar(440, 0, 0.5, 0.5) (0, 1) unipolar
*/
(
{
//2009 Collins et al.
var carrier, modulator, carrfreq, modfreq;

carrfreq= MouseX.kr(440,5000,'exponential');
modfreq= MouseY.kr(1,5000,'exponential');

carrier= SinOsc.ar(carrfreq,0,0.5);
modulator= SinOsc.ar(modfreq,0,0.25, 0.25);

carrier*modulator;
}.scope
)


// another example, One possitive one negative

{SinOsc.ar(440, 0, SinOsc.ar(0.5), SinOsc.ar(0.5))}.scope

// both possitive and negative

{SinOsc.ar(440, 0, SinOsc.ar(0.25), 0.25)}.scope

// adding a MouseX variable to control the modulation of the amplitude

{
var carrier, modulator, carrfreq, modfreq, modamp;

carrfreq= MouseX.kr(440,5000,'exponential');
modfreq= MouseY.kr(1,5000,'exponential');
modamp = MouseX.kr(0.1, 1, 'exponential');
carrier= SinOsc.ar(carrfreq,0,0.5);
modulator= SinOsc.ar(modfreq,0,SinOsc.ar(modamp), SinOsc.ar(modamp));

carrier*modulator;
}.scope

/*
Fm synthesis (frequency modulation) is a technique of changing the timbre 
of a waveform by modulating its frequency.
*/
(
var synth;
synth= {| carrfreq=440, modfreq=1, moddepth=0.01| 
SinOsc.ar(carrfreq + MouseX.kr(moddepth, 5000, 'exponential')*SinOsc.ar(MouseY.kr(modfreq, 10000, 'exponential')),0,0.25)
}.scope;
)


// control the carrfreq as well

(
var synth;
synth= {| carrfreq=440, modfreq=1, moddepth=0.01| 
SinOsc.ar(MouseX.kr(carrfreq, 10000, 'exponential') + MouseX.kr(moddepth, 5000, 'exponential')*SinOsc.ar(MouseY.kr(modfreq, 10000, 'exponential')),0,0.25)
}.scope;
)


//Create a window with sliders to control the frequency modulation (Collins 2009 et al. sc_tutorials)

(
var w, carrfreqslider, modfreqslider, moddepthslider, synth;

w=Window("frequency modulation", Rect(100, 400, 400, 300));
w.view.decorator = FlowLayout(w.view.bounds);

synth= {arg carrfreq=440, modfreq=1, moddepth=0.01; 
SinOsc.ar(carrfreq + (moddepth*SinOsc.ar(modfreq)),0,0.25)
}.scope;

carrfreqslider= EZSlider(w, 300@50, "carrfreq", ControlSpec(20, 5000, 'exponential', 10, 440), {|ez|  synth.set(\carrfreq, ez.value)});
w.view.decorator.nextLine;

modfreqslider= EZSlider(w, 300@50, "modfreq", ControlSpec(1, 5000, 'exponential', 1, 1), {|ez|  synth.set(\modfreq, ez.value)});
w.view.decorator.nextLine;
moddepthslider= EZSlider(w, 300@50, "moddepth", ControlSpec(0.01, 5000, 'exponential', 0.01, 0.01), {|ez|  synth.set(\moddepth, ez.value)});

w.front;
)

//Phase Modulation
(
{
//2009 Collins et al.
var modf, ind;

modf= MouseX.kr(1,440, 'exponential');
ind=MouseY.kr(0.0,10.0);

SinOsc.ar(440, SinOsc.ar(modf,0,modf*ind),0.25)
}.scope
)
#+END_SRC
