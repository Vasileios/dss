[
{
	"uri": "https://vasileios.github.io/dss/_index.en/",
	"title": "AC",
	"tags": [],
	"description": "",
	"content": " AC Classes Algorithmic Composition \u0026amp; Sound Synthesis\n"
},
{
	"uri": "https://vasileios.github.io/dss/introduction/history.en/",
	"title": "History",
	"tags": [],
	"description": "",
	"content": "Chapter 1 History "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/_index.en/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Algorithmic Composition Algorithm is:\n A set of mathematical instructions that must be followed in a fixed order, and that, especially if given to a computer, will help to calculate an answer to a mathematical problem. A systematic procedure that produces – in a finite number of steps the answer to a question or the solution of a problem. [...] (especially computing) a set of rules that must be followed when solving a particular problem. (Nierhaus 2009 p.2)  "
},
{
	"uri": "https://vasileios.github.io/dss/",
	"title": "Αλγοριθμική Σύνθεση",
	"tags": [],
	"description": "",
	"content": " Αλγοριθμικη Συνθεση Αλγοριθμική Σύνθεση και Δόμηση Ήχου (2018)\n\u0026ldquo;Τεχνών Ήχου και Εικόνας\u0026rdquo;\nΙόνιο Πανεπιστήμιο\nΔιδάσκων: Β. Αγιομυργιανάκης\n"
},
{
	"uri": "https://vasileios.github.io/dss/introduction/",
	"title": "Εισαγωγή",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Αλγοριθμικη Συνθεση Αποσπάσματα κυρίως απο το βιβλίο \"Algorithmic Composition: Paradigms of Automated Music Generation\" (Nierhaus 2009).\nΟ αλγόριθμος είναι:\n \"- Ένα σύνολο μαθηματικών οδηγιών που πρέπει να ακολουθηθούν για τον υπολογισμό μιας απάντησης σε ένα μαθηματικό πρόβλημα. Μια συστηματική διαδικασία που παράγει - σε ένα πεπερασμένο αριθμό βημάτων την απάντηση σε μια ερώτηση ή τη λύση ενός προβλήματος. (κυρίως για υπολογιστές) ένα σύνολο κανόνων που πρέπει να ακολουθηθούν για να επιλυθεί ένα συγκεκριμένο πρόβλημα\". (Nierhaus 2009 2)  Αλγοριθμική σύνθεση\n\"Ο όρος παραπέμπει πως οι κανόνες αυτοί προέρχονται κυρίως από τον χώρο των μαθηματικών, με τη μορφή απλών αριθμητικών πράξεων ή περισσότερο σύνθετων δομών όπως για παράδειγμα στατιστικά μοντέλα, σύνολα, συναρτήσεις, γεωμετρίες κ.λπ. Σε άλλες περιπτώσεις ακολουθούνται διαφορετικές προσεγγίσεις οι οποίες προέρχονται από ένα πλήθος διαφορετικών πεδίων: εξελικτικά βιολογικά μοντέλα και γενετικοί αλγόριθμοι, ειδικές γραμματικές, συστήματα μηχανικής μάθησης και τεχνητής νοημοσύνης, κυτταρικά αυτόματα κ.ο.κ.\" (Λώτης \u0026 Διαμαντόπουλος 2015 254)\n"
},
{
	"uri": "https://vasileios.github.io/dss/introduction/history/",
	"title": "Ιστορία",
	"tags": [],
	"description": "",
	"content": "chapter 1 Ιστορια Μουσική και μαθηματικά.\nΠυθαγόρας\nΟ ήχος των σφυριών των σιδηρουργών έκανε τον Πυθαγόρα να βγάλει σημαντικά συμπεράσματα σχετικά με τη φύση του τονισμού και τα μαθηματικά με βάση την αρμονία μετά τη σύγκριση των τονισμών που έγιναν απο τα σφυριά.\nGuido D'Arrezo\nΕπίσης, στο πλαίσιο της αλγοριθμικής σύνθεσης, γύρω στο AD 1000 είχε αναπτυχθεί η πρώτη προσέγγιση στην αυτόματη γένεση της μουσικής δομής. Ο Guido του Arezzo (γύρω στο 991-1031) συνέβαλε στην ανάπτυξη της σημειογραφίας, ανέπτυξε το 'solfeggio' (1025) και ήταν ένας σημαντικός μουσικός θεωρητικός της μεσαιωνικής εποχής. Ένα από τα σημαντικότερα έργα του, το \"Micrologus\", είναι η πρώτη συλλογή της μονοδικής και πολυφωνικής πρακτικής τραγουδιού. Εφηύρε μια μέθοδο για την αυτόματη μετατροπή του κειμένου σε μελωδικές φράσεις. Για παράδειγμα, τα φωνήεντα στο κείμενο μπορούν να χαρτογραφηθούν σε διαφορετικές θέσεις τονισμού.\n Πολυφωνία, Motet 12-13ος αιώνα  To motet μαζι με τη ανάπτυξη της μουσικής σημειογραφίας είχαν μεγάλη σημασία για την ανάπτυξη της αλγοριθμικής σύνθεσης.\nΟ Leonin με το \"Magnus liber organi de gradali et antiphonario\", μια συλλογή από χωρικά (chorales), είναι απο τους πρώτους που ασχολήθηκε με την πολυφωνία και το μοτετ.\nΑπο τις αρχές του 12ου αιώνα μέχρι τις αρχές του 13ου αιώνα με τους Perotin και Petrus de Cruce, το motet εξελίχθηκε από συνθέτες όπως ο Philippe de Vitry (γύρω στο 1291-1361), και αργότερα με τον Giovanni Pierluigi Palestrina (1525–1594)\nΗ αρχή του ισόρυθμου (isorhythm), που εφευρέθηκε από τον Philippe de Vitry και εξελίσεται με τον Guillaume de Machaut, αποτελείται από πολλαπλά επαναλαμβανόμενα μελωδικά και ρυθμικά μοντέλα τα οποία αλληλεπιδρούν μεταξύ τους και μπορούν να εμφανιστούν σε διαφορετικές αναλογίες.\nDe Vitry\nMachaut\nJohann Joseph Fux\nΟ Fux κωδικοποίησε κάποιους κανόνες οι οποίοι περιγράφουν βασικές αντιστικτικές τεχνικές της τονικής μουσικής.(Cope 2000)\nΗ γέννηση του κανόνα στα τέλη του 15ου αιώνα.\n'Αλλα γνωστά παραδείγματα, στην εποχή του Μπαρόκ όπως η τεχνική των δώδεκα τόνων του Bach \"The Art of Fugue\" καθώς και τεχνική του Schönberg τον 20ο αιώνα, οδηγούν συχνά στην ανάπτυξη της πολυπλοκότητας αποκλειστικά στο πλαίσιο της ευρωπαϊκής ή δυτικής μουσικής τέχνης.\nArs Magna\nΑν οι προαναφερθείσες αρχές αντιπροσωπεύουν τις αρχές της αλγοριθμικής χειραγώγηση του μουσικού υλικού, τότε το \"Ars Magna\" του Raimundus Lullus διαπραγματεύεται αποτελεσματικά την έννοια του υπολογιστικού μουσικού συστήματος.\nΟι αναλογίες σχετικά με το hardware και το λογισμικό, τη μνήμη δεδομένων, το πρόγραμμα κλπ. είναι εμφανείς στα συστατικά, τους ορισμούς και τους κανόνες του \"Ars Magna\".\nAthanasius Kircher\nO Kircher με το μουσικολογικό έργο του \"Musurgia Universalis\" από το 1650 επιρρέασε στην ανάπτυξη της δυτικής μουσικής - ιδιαίτερα στους J.S.Bach (1685-1750) και Beethoven (1770-1827)(Glasgow University).\nΜία απο τις δημιουργίες του ήταν και μια συσκευή που είχε ως σκοπό τη σύνθεση εκκλησιαστικής μουσικής και απο μή μουσικούς. Το Arca Musarithmica θεωρείται αλγοριθμική σύνθεση σε φυσική μορφή.\nΤο σύστημα αυτό αποτελείται από τρεις κατηγορίες ετικετών ξύλινων ραβδιών (συντάγματα) στις οποίες χαράσσονται και αριθμοί και ρυθμικές αξίες. Το σύστημα του Kircher επιτρέπει την αυτόματη δημιουργία συνθέσεων με το στυλ της απλής αντίστιξης. Σε μια προχωρημένη μορφή, μπορεί να παραχθεί υλικό για συγκεκριμένα στυλ μουσικής.\nδείτε εδω περισσότερα\nLeibnitz (1646-1716)\nLeibnitz\n\"Καθολική γλώσσα\"\nΤυποποίηση των επιστημών.\n..υποδομήστε τη λύση οποιουδήποτε επιστημονικού προβλήματος μέσα σε ένα ολοκληρωμένο Λογισμό.\nΗ έννοια της καθολικής γλώσσας ήταν επίσης ένα όραμα διακρατικής επικοινωνίας στην Ευρώπη μετά τον τριακονταετή πόλεμο.\nΠροϋποθέσεις του προγράμματος:\n Προκατασκευή εγκυκλοπαίδειας (ορισμοί) για τις τυπικές επιστήμες.   Ανάπτυξη ενός επίσημου συστήματος, δηλαδή \"lingua universalis\", στο οποίο μπορούν να κωδικοποιηθούν όλοι οι επιστημονικοί όροι.   Δημιουργία του \"λογισμού εγκυρότητας\" που θα επιτρέψει τη σύνδεση όλων των όρων της παγκόσμιας γλώσσας με λογικές λειτουργίες.  Χρήση συμβόλων για την αναπαραγωγή όλων των επιστημονικών όρων.\nΩς σύνολο συμβόλων, ο Λαίμπνιτς επέλεξε να είναι η ομάδα των φυσικών αριθμών.\nΓια παράδειγμα,\n  Πράγμα = 2  Όν = 6 = 2 * 3  Ανθρώπινο Όν = 30 = 6 * 5  κ.λπ.  \"Η μουσική είναι μια ασκούμενη μαθηματική εξάσκηση, το nescientis είναι αριθμητική animi\" (\"Η μουσική είναι μια κρυμμένη αριθμητική άσκηση της ψυχής, η οποία δεν γνωρίζει ότι μετράει\").\nΥπολογιστική διαδικασία \u0026 μηχανές - Calculus\nΗ μηχανοποίηση των υπολογιστικών διαδικασιών, 1617 ξεκίνησε από τη Σκωτία απο τον μαθηματικό John Napier και Jost Bürgi (1552-1632) πρωτοστάτησαν στο πεδίο των λογαρίθμων με το \"Mirifici logarithmorum canonis\" descriptio \"που εμφανίζεται το 1614, σχεδιασμένο για πολλαπλασιασμό και διαίρεση, με βάση την αρχή του Πυθαγόρειου άβακα. (1550-1617).\nΟ άβακάς του Napier, γνωστό και ως οστά του Napier (Napier's bones).\nNapier's bones\nΠαρόμοια με τα οστά του Napier:\nCaspar Schott (1608-1666), \"Organum Mathematicum\" (1668)\nΗ ιδέα του Leibniz για την εφαρμογή του δυαδικού αριθμητικού συστήματος σε ένα αυτοματισμό πραγματοποιήθηκε με μια εφεύρεση στην κλωστοϋφαντουργία. Το έτος 1725 ο Basile Bouchon ανέπτυξε το πρώτο σύστημα αυτόματου ελέγχου Αργαλειών (Bouchon loom).\nBabbage-Lovelace 18ος αιώνας\nΒασικός στόχος του Babbage είναι η μηχανοποίηση των διαδικασιών υπολογισμού, όπως αυτές απαιτούνται για τη δημιουργία πινάκων λογαρίθμου.\nΠαράλληλα με τον Babbage, η Ada Countess of Lovelace (1815-1852) διαδραμάτισε σημαντικό ρόλο. Ήταν μια αυτοδίδακτος μαθηματικός και συνεργάστηκε με τον Babbage στην έννοια του «αναλυτικού κινητήρα» (analytical engine).\nAda Lovelace\nΤο 1840, ο Babbage έδωσε μια σειρά μαθημάτων στο Τορίνο για την εφεύρεσή του. Με βάση αυτό το υλικό, ο Ιταλός μαθηματικός Luigi Federico Menabrea δημοσίευσε το άρθρο “Notions sur la machine analytique de Charles Babbage” το 1842. Η Ada Lovelace μετέφρασε αυτό το κείμενο στα αγγλικά το 1843 και πρόσθεσε τις δικές της αναλυτικές εκτιμήσεις για το υλικό, συμπεριλαμβανομένων των εννοιών loop, subroutine and the conditional jump (βρόχου, της υπορουτίνας και του άλματος υπό όρους). Η κοντέσσα Ada Lovelace θεωρείται η πρώτη γυναίκα προγραμματιστής στην ιστορία του προγραμματισμού ηλεκτρονικών υπολογιστών - το πρόγραμμα Ada, που αναπτύχθηκε στη δεκαετία του 1970, πήρε το όνομά της.\nDice Game\nΕπιπλέον, μπορούν να βρεθούν οι πρώτες εφαρμογές αλγορίθμων για εργασίες σύνθεσης στο δημοφιλές \"μουσικό παιχνίδι με ζάρια\" τον 18ο αιώνα.\nΤο πρώτο παιχνίδι των ζαριών είναι το \"Der allezeit fertige Menuetten- und Polonaisencom- ponist\" του Johann Philipp Kirnberger, το οποίο σχεδιάστηκε το 1757, μέχρι το έτος 1812, δημιουργήθηκαν τουλάχιστον 20 άλλες δημιουργίες αυτού του τύπου. (Nierhaus 2009 36)\nΛογικές λειτουργίες\nBoole (1815-1864)\nΟ George Boole (1815-1864) ο οποίος ανέπτυξε στο συγγραφικό του έργο «Η Μαθηματική Ανάλυση της Λογικής» (1847) και «Διερεύνηση των νόμων της σκέψης» (1854) έχει εκπροσωπήσει τον φορμαλισμό για την παρουσίαση της προτασιακής λογικής.\nShannon (1916-2001)\nAlgebra Boolean σε ηλεκτρονικά κυκλώματα\n  X1\u0026or;(X4\u0026and;(X2\u0026and;X3))  ο Γιάννης Ξενάκης (1922-2001) σε διάφορες συνθέσεις του εφάρμοσε λογικούς συνδυασμούς για τη δημιουργία μουσικής δομής από τη θεωρία των κοσκίνων.\nΤο φάσμα εφαρμογών της λογικής επεκτέινεται με ένα σύστημα που ειναι ο προπομπός της σημερινής \"first-order logic\". Ο βασικός υπολογισμός γίνεται ένας μηχανισμός θεμελιώδους μαθηματικής έρευνας, των οποίων οι στόχοι οδηγούν σε πολώσεις μεταξύ των επιστημόνων. Οι «φορμαλιστές» του David Hilbert (1862-1943) είχαν ως στόχο να θέσουν βασικούς μαθηματικούς όρους σε μια αξιωματική βάση και να αποδείξουν την συνοχή τους (αξιωματικό σύστημα).\nΑντίθετα, οι \"Διανοούμενοι\" που ιδρύθηκαν από τον Luitzen Egbertus Jan Brouwer (1881-1966), δεν συμφωνούσαν με τους φορμαλιστές και προκάλεσαν τον David Hilbert, σε μια επική προσπάθεια, να θέσει την αριθμητική των φυσικών αριθμών σε μια αξιωματική επιβεβαιωμένη βάση και επίσης να αποδείξει τη συνοχή των μαθηματικών πεδίων, όπως η θεωρία των συνόλων.\n\"Theoretical Logic\" Automatic processing of Logical Calculus.\nDecidability Problem (Πρόβλημα απόφασης)\nΈνα πρόβλημα απόφασης που μπορεί να επιλυθεί με έναν αλγόριθμο, ονομάζεται decidable (αποκρίσιμο).\nΟ Hilbert μίλησε για τα μαθηματικά προβλήματα είναι άλυτα και έθεσε κάποια απο αυτά όπως να αποδειχθει η πληρότητα και μη αντιφατικοτητα των αξιωματων της αριθμητικης.\nThe idea that there could be an algorithm being able to decide for any first order logical expression if its statement is true or false.\nor\nthe halting problem of a Turing machine το οποίο είναι μή αποκρίσιμο.\nKurt Gödel\n\"On Formally Undecidable Propositions of the Principia Mathematica Related Systems \".\no Kurt Gödel το 1931 καθόρισε σαφή όρια στις προσπάθειές των φορμαλιστών σε σχέση με τις αξιωματικές θεωρίες. Με το Incompleteness Theorems (θεώρημα της μη πληρότητας) έδειξε πρώτα ότι σε ένα αρκετά ισχυρό σύστημα που περιέχει τουλάχιστον αριθμητική, η συνέπεια του συστήματος δεν μπορεί να αποδειχθεί (μη πληρότητα) μέσα στο σύστημα με τα δικά του μόνο αξιώματα. Δεύτερον, κατάφερε να αποδείξει ότι σε ένα τέτοιο σύστημα μπορούν να γίνουν προτάσεις που στο πλαίσιο αυτού του συστήματος δεν είναι ούτε πλήρες ούτε συνεπές.\nΑυτά τα αποτελέσματα είχαν μεγάλη επίδραση στη φιλοσοφία των μαθηματικών και της λογικής.\nΠαρόλα αυτά, οι επιτυχίες του Hilbert και των φορμαλιστών έθεσε τις βασεις για την ανάπτυξη της μαθηματικής λογικής.\nJohn von Neumann\nJohn von Neumann\n John von Neumann (1903-1957) - game theory and quantum mechanics, Von Neumann architecture in computing, linear programming, self-replicating machines, stochastic computing.  IAS computer 1952 (5 kilobytes capacity)\nTheory of Self-Reproducing Automata\nWorkable definition of an algorithm\nDavid Hilbert\n Hilbert's decision problem Given a mathematical proposition, can one find an algorithm to decide whether the proposition is true or false?  Alan Turing\nTuring's Thesis was that:\nAny \"algorithm\" can be carried out by one of his machines.\nTuring Machine\n  Infinte tape  Symbols 0, 1 and blank \"\"  Read/Write head  Read the symbol on the square under the head.  Leave it unchanged or edit the symbol by writing another symbol.  Move the tape left or right by one square so that the machine can read  and edit the symbol on a neghbouring square.   Cracking Enigma Machine  A Polyalphabetic machine.\n The Imitation Game  Mind A Quarterly review of Psychology and Philosophy Computing machinery and Intelligence\n The Turing Test  Computers between 1930s and 50s\nBell Laboratory:\nKonrad Zuse\n Zuse3 or Z3 1941  Από το 1934 έως το 1938, ο Konrad Zuse ανέπτυξε το πρώτο του μοντέλο υπολογιστικής μηχανής με βάση το πρόγραμμα. Το Z1 (Zuse 1) κατασκευάστηκε αποκλειστικά από μηχανικά εξαρτήματα. Ο Zuse χρησιμοποίησε μια μνήμη ικανή να αποθηκεύσει 16 δυαδικούς αριθμούς 24 bit, ο καθένας από τους οποίους αποτελείται από μεταλλικά φύλλα που μπορούν να επανατοποθετηθούν. Παρόλο που η ιδέα του θεωρήθηκε σωστή, προέκυψαν κάποια προβλήματα λόγω του μηχανικού φορτίου υλικού. Στα μοντέλα παρακολούθησης Z2 (1940) και Z3 (1941), τα μηχανικά στοιχεία μεταγωγής αντικαταστάθηκαν από ρελέ. Το Z3, που θεωρείται ο πρώτος προγραμματιζόμενος ηλεκτρονικός υπολογιστής, επέτρεψε την επεξεργασία \"floating-point numbers\" που δεν εφαρμόστηκαν σε παρόμοια μοντέλα, όπως Mark I, ENIAC και άλλα, της εποχής εκείνης. Η (half-logarithmic notation ) που χρησιμοποιείται από τον Zuse επιτρέπει μια πιο αποτελεσματική αριθμητική αναπαράσταση από τη \"fixed-point notation\" που χρησιμοποιείται σε παρόμοια μοντέλα υπολογιστών.\nHoward Hathaway Aiken\n Mark I Από το 1934, ο Howard Hathaway Aiken (1900-1973) σχεδίασε, σε συνεργασία με την IBM, το Mark I, το οποίο παρουσιάστηκε για πρώτη φορά στο Harvard το 1944. Η μηχανή του Aiken βασίζεται στο δεκαδικό σύστημα και αποτελείται από μια διασύνδεση των μηχανών του Hollerith τον υπολογισμό των γενικών αριθμητικών εργασιών.   Mark Ι sequentially programmed step by step one operation after the other.  The Mark I also computed and printed mathematical tables, which had been the initial goal of British inventor Charles Babbage for his \"analytical engine\".\nH Grace Murray Hopper (1906-1992) εργάστηκε στον προγραμματισμό του Mark I, υπογράφοντας την έννοια της υπορουτίνας (subroutine) και συνέβαλε σημαντικά στην ανάπτυξη του πρώτου μεταγλωττιστή (compiler), ο οποίος ολοκληρώθηκε το 1952 ως στρατιωτική εφεύρεση. Η Grace Hopper ήταν μαζί με την Ada Lovelace μία από τις γυναίκες πρωτοπόρους της ανάπτυξης ηλεκτρονικών υπολογιστών και μετά το 1945 προήχθη σε ναύαρχο για να γίνει η ανώτατη γυναίκα του αμερικανικού στρατού.\nJohn Vincent Atanasoff\n ABC Μεταξύ 1937 και 1942, ένας δυαδικός υπολογιστής (binary computer) για την επίλυση συστημάτων εξισώσεων αναπτύχθηκε από τον John Vincent Atanasoff (1903-1995) και από τον υποψήφιο διδάκτορα του Clifford Edward Berry (1918-1963) στο Iowa State College. Ο υπολογιστής Atanasoff-Berry (σύντομος: ABC) εγκατέλειψε εντελώς την περίπλοκη τεχνολογία των μηχανικών ρελέ υπέρ των νέων σωλήνων ηλεκτρονίων και διέθεσε μια δυναμική μνήμη καθώς και ανεξάρτητες μονάδες υπολογισμού.  John Mauchly and J. Presper Eckert\n John Mauchly and J. Presper Eckert in 1946 with ENIAC computer. ENIAC used patching and it wasn't sequentially programmed.  Maurice Wilkes\n Maurice Wilkes EDSAC 1949 (Electronic Delay Storage Automatic Computer)  \"First Draft of a Report on the EDVAC\" by John von Neumann 1945.\nThis report outlines the computer architecture for the next 50 years.\nO EDCVAC σε αντίθεση με το ENIAC I, το οποίο βασίζεται στο δεκαδικό σύστημα, η αναπαράσταση δεδομένων είναι δυαδική. Οι εντολές βρόχου και άλματος ήταν δυνατές και αργότερα, με βάση την έννοια του John von Neumann (1903-1957), κατέστη δυνατή η αποθήκευση εντολών προγράμματος πέρα από τα δεδομένα στη μνήμη.\n John Von Neumann - IAS machines (Institute for Advanced Studies at Princeton) (1946-1952).  Χρησιμοποιώντας ηλεκτροστατικό σωλήνα αποθήκευσης ως εναλλακτική λύση στις Mercury delay lines.\nΑυτή η εναλλακτική λύση προσέφερε την τυχαία πρόσβαση παρά την κυκλική πρόσβαση - \"read in parallel rather than serially\".\nVon Neumann machines (parallel binary machines)\n UNIVAC   MANIAC (Los Alamos) 1952  Δείτε παρακάτω ένα ντοκιμαντέρ σχετικά με την ιστορία και τους εφευρέτες των υπολογιστών.\nComputer Pioneers\nΑλγοριθμική σύνθεση τον 20ο αιώνα Serialism\nJohn Cage \"Reunion\" (σκάκι)\nEdgard Varèse Poème électronique στο Philips Pavilion.\nIannis Xenakis και αλγοριθμική σύνθεση.\nFormalised Music (\"aesthetic efficiency\")\nXenakis Analogique A\nHiller and Isaacson Illiac Suite\nLigeti Continuum 1968\nHerbert Brün \"SAWDUST\" Dust (1976), More Dust (1977) etc.\nGottfried Michael Koenig SSP (Sound Synthesis Program)\nand more...\n"
},
{
	"uri": "https://vasileios.github.io/dss/introduction/paradigms.en/",
	"title": "Paradigms",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Paradigms "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/paradigms/",
	"title": "Παραδείγματα",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Παραδειγματα Μαρκοβιανά Μοντέλα - Markov models time dependent random variables (TDRV)\nΣτο πλαίσιο των πειραμάτων και παρατηρήσεων σχετικά με την TDRV έχουν ήδη γίνει από τους Pierre Simon de Laplace και Daniel Bernoulli. Η πρώτη εφαρμογή αυτής της μεθόδου ήταν μια εκτενή ανάλυση κειμένου από τον Markov: \"Το 1913 ο Markov είχε δημοσιεύσει την τρίτη έκδοση του εγχειριδίου του. Σε αυτή την έκδοση γράφει: «Ας τελειώσουμε το άρθρο και ολόκληρο το βιβλίο με ένα καλό παράδειγμα TDRV, που μπορούν να θεωρηθούν ως μια απλή αλυσίδα» (chain).\n Markov chains or models    Markov chain - Markov process: Ένα στοχαστικό μοντέλο ή διαδικασία ... η πιθανότητα κάθε συμβάν εξαρτάται μόνο από την κατάσταση που επιτεύχθηκε στο προηγούμενο συμβάν.  Ο όρος \"αλυσίδα Markov\" (ή Markov Models για αυτή την κατηγορία των στοχαστικών διαδικασιών χρησιμοποιήθηκε για πρώτη φορά το 1926 σε μια δημοσίευση του Ρώσου μαθηματικού Σεργκέι Νατανοβιτς Μπερνστάιν.\nΟ Markov μελέτησε τη σειρά των 20.000 γραμμάτων στο ποίημα του AS Pushkin «Eugeny Onegin», ανακαλύπτοντας ότι η σταθερή πιθανότητα των φωνηέντων σε αυτό το ποίημα είναι p = 0.432, η πιθανότητα ενός φωνήεντος να ακολουθείται απο ένα άλλο είναι p1 = 0.128 και ότι η πιθανότητα ενός φωνήεντος να ακολουθείται απο σύμφωνο είναι p2 = 0.663. (στοχατική διαδικασία)\n  Stochastic (πιθανοκρατική)  Stochastic processes are used to describe a sequence of random events dependent on the time parameter (t).  vs  Deterministic (αιτιοκρατική)  Το ντετερμινιστικό σύστημα είναι ένα σύστημα στο οποίο δεν υπάρχει τυχαία συμπεριφορά στην ανάπτυξη μελλοντικών καταστάσεων του συστήματος. Επομένως, ένα ντετερμινιστικό μοντέλο θα παράγει πάντα την ίδια έξοδο από μια δεδομένη αρχική κατάσταση.  To πεδίο της στοχαστικής διαδικασίας περιλαμβάνει υπολογίσμο πιθανοτήτων, (probability calculus) και στατιστική.\nΣε μια στοχαστική αλυσίδα, κάθε διακριτός χρόνος t έχει μια τυχαία μεταβλητή Χ. Σε μια αλυσίδα Markov, η οποία είναι ένα ιδιαίτερο είδος στοχαστικής αλυσίδας, η πιθανότητα της μελλοντικής κατάστασης Xtm+1 (η τυχαία μεταβλητ Χ τη στιγμή t + 1) εξαρτάται από την τρέχουσα κατάσταση Xt. Για τους δεδομένους χρόνους tm και tm+1, αυτή η πιθανότητα είναι:\n  Stochastic Process - Markov Chain  P(Xtm+1=j|Xtm=i)=Pij(tm,tm+1)  Markov models in algorithmic composition\nH εφαρμογή των διεργασιών Markov στη δημιουργία μουσικών δομών Εξετάστηκε πρώτα από τον Harry F. Olson (1901-1982) περίπου το 1950. Ο Olson ήταν Αμερικανός ηλεκτρολόγος μηχανικός και φυσικός που επικεντρώθηκε στην ακουστική έρευνα. Μαζί με τον Henry Belar, ανέπτυξε το \"Electronic Synthesizer\" το 1955, το πρώτο μηχάνημα που ονομάστηκε \"συνθεσάιζερ\".\ntransition probabilities\nΟ Hiller και ο Isaacson το 1955 με 1956 χρησιμοποιούν Markov μοντέλα για την παραγωγή της μουσικής δομής με το \"Illiac Suite\".\nHiller \u0026 Iaacson: The Illiac Suite\nΜεταξύ άλλων, αυτά τα μοντέλα Markov χρησιμεύουν για την μουσική σύνθεση διαφόρων ειδών μουσικής. Τα μοντέλα Markov χρησιμοποιούνται ως επί το πλείστον στον τομέα της μίμησης του στυλ μουσικής. Έχουν χρησιμοποιηθεί και απο τον Ξενάκη, σαν τεχνικές σύνθεσης μουσικού υλικού στα έργα του το 1958. Στα \"Analogique A\" χρησιμοποιούνται μοντέλα Markov για την οργάνωση τμημάτων διαφορετικής πυκνότητας (segments of differing density arrangement).\nXenakis Analogique A\nGenerative grammars Οι γενετικές γραμματικές είναι μέθοδοι για την αλγοριθμική σύνθεση και τη μουσική ανάλυση. Το βασικό γλωσσικό μοντέλο που ανέπτυξε ο Noam Chomsky το 1957, είναι το αρχικό σημείο για την εφαρμογή αυτών των γενικών αρχών στη μουσική.\nTHe representation of language rules have been classified into four types (zero to three) by Noam Chomsky (1957) (Holtzman 2015)\nΤα έργα των Roads, Steedman, Sundberg, Lerdahl, Jackendoff και άλλων από τη δεκαετία του '70 αναδεικνύουν την εφαρμογή γενετικών γραμματικών στην παραγωγή και την ανάλυση της μουσικής δομής. Τα πεδία που χρησιμοποιούν συχνά γενετικές γραμματικές είναι η παραδοσιακή ευρωπαϊκή μουσική, η τζαζ, καθώς και η μουσική εθνολογία. Σχετικοί φορμαλισμοί με τις γενετικές γραμματικές είναι τα \"Lindenmayer systems\" μια κατηγορία αλγορίθμων (βιολογία) για την παρατήρηση και κατανόηση της εξελικτικής διαδικασίας, καθώς και τα \"αυξημένα μεταβατικά δίκτυα\" (augmented transition networks), τα οποία χρησιμοποιούνται στην περίπτωση του David Cope, κ.ο.κ.\nΜεταβατικά δίκτυα-Transition networks Το πρόγραμμα του David Cope “EMI” Το “EMI” δημιουργεί απομιμήσεις αφού πρώτα αναλύσει έναν επαρκή αριθμό συνθέσεων ενός συγκεκριμένου είδους όπως για παράδειγμά νόμους και κανόνες σύνθεσης της σονάτας.\nEMI history\nDavid Cope music\nDavid Cope Website\nChaos and self-similarity Ο όρος \"χάος\" προέρχεται από την ελληνική γλώσσα και αρχικά σήμαινε \"διάστημα\" ή \"άβυσσο\".\nΣήμερα, η λέξη χρησιμοποιείται συνειδητά με την έννοια της \"διαταραχής\", όρος που αποκτήθηκε τον 17ου αιώνα. Σε ένα μαθηματικό και φυσικό περιβάλλον, η Χαοτική θεωρία σε στενότερη έννοια αναφέρεται επίσης ως η θεωρία της μη γραμμικής δυναμικής (non-linear dynamics). Το 1975, ο όρος \"χάος\" εισήχθη στον τομέα των μαθηματικών από τους Tien-Yien Li και James Yorke.\nΤο πιο γνωστό παράδειγμα περίπλοκης συμπεριφοράς συστήματος πηγαίνει πίσω στο Lorenz ο οποίος το 1963 ανέπτυξε ένα σύστημα τριών συζευγμένων μη γραμμικών διαφορικών εξισώσεων ως ένα απλοποιημένο μοντέλο για την ατμοσφαιρική ροή.\n  Το \"φαινόμενο της πεταλούδας\"  Ένα πτερύγιο των πτερυγίων μιας πεταλούδας  προκαλεί ελάχιστη αναταραχή, η οποία ωστόσο, κατά τη διάρκεια της  ντετερμινιστικής χαοτικής ανάπτυξης του συστήματος, μπορεί να οδηγήσει  σε εντελώς απρόβλεπτες μετεωρολογικές συνέπειες και σε πολύ  απομακρυσμένες περιοχές.  Gary Lee Nelson* *Charles Wuorinen\nFractals, Lindenmayer systems\n Fractal geometry (Fragmented): Mandelbrot, Random walk, brown noise, etc L-systems: biology - Growth of living organisms such as algea and plants.  Γενετικοί αλγόριθμοι-Genetic algorithms Οι γενετικοί αλγόριθμοι ώς μιά κλάση των εξελικτικών αλγορίθμων (evolutionary algorithms), για παράδειγμα, στρατηγικών μοντέλων για φυσικά συστήματα, είναι στοχαστικές τεχνικές αναζήτησης.\nΤα βασικά μοντέλα εμπνεύστηκαν από τη θεωρία της εξέλιξης του Δαρβίνου.\nΟι Γενετικοί αλγόριθμοι, χρησιμοποιούνται για την μοντελοποίηση της εξελικτικής διαδικασίας στον υπολογιστή.\nΗ ορολογία των γενετικών αλγορίθμων συμπεριλαμβανομένης της \"επιλογής\", της \"μετάλλαξης\", της \"επιβίωσης του ικανότερου\", κλπ. σχετίζεται με τις διαδικασίες βιολογικής επιλογής.\nΑπό τη δεκαετία του 1960, οι Ingo Rechenberg και Hans-Paul Schwefel εισήγαγαν τις στρατηγικές εξέλιξης στο Τεχνικό Πανεπιστήμιο του Βερολίνου και στη δεκαετία του 1970 οι Αμερικανοί John H. Holland και David E. Goldberg ανέπτυξαν γενετικούς αλγόριθμους. Τα μοντέλα Rechenberg και Schwefel βασίζονται σε μια γραφική παράσταση και έχουν διαμορφωθεί με βάση βιολογικές διαδικασίες για την ανάπτυξη τεχνικών βελτιστοποίησης.\nJohn Henry Holland\nGENETIC ALGORITHMS AND ADAPTATION\nΑυτή η κατηγορία αλγορίθμων είναι ιδιαίτερα κατάλληλη για εργασίες που είναι δύσκολο να μοντελοποιηθούν μαθηματικά και που δεν έχουν ένα σαφές σύστημα κανόνων.\nΚυτταρικά αυτόματα-Cellular automata Τα \"Κυτταρικά Αυτόματα\" δημιουργήθηκαν για πρώτη φορά στη δεκαετία του 1940 και κέρδισαν μεγάλη δημοτικότητα αφού δημοσιεύτηκαν στο \"Scientific American\" το 1970. Αυτή η κατηγορία αλγορίθμων μπορεί να παρουσιάσει εξαιρετικά περίπλοκη συμπεριφορά με βάση σχετικά απλούς αρχικούς κανόνες. Τα κυτταρικά αυτοματοποιημένα συστήματα είναι λιγότερο κατάλληλα για εφαρμογές απομίμησης ύφους (style imitation).\nΟ Miranda περιγράφει διάφορες εφαρμογές μοντέλων κυτταρικών αυτομάτων (CA) για μουσικές εφαρμογές. Σε ένα από αυτά, το Chaosynth, ένας χημικός ταλαντωτής χρησιμοποιείται για την παραμετροποίηση μιας μηχανής κοκκώδους σύνθεσης (Miranda 2000).\nΤα κυτταρικά αυτόματα είναι δυναμικά συστήματα στα οποία ο χώρος και ο χρόνος είναι διακριτός. (Gutowitz 1991)\nNeural networks Τα \"Νευρωνικά Δίκτυα\" δημιουργήθηκαν αρχικά για εργασίες αναγνώρισης εικόνων. Η εννοιολογική τους σχέση με την επεξεργασία βιολογικών πληροφοριών είναι ένας λόγος για τη μεγάλη τους δημοτικότητα. Στην αλγοριθμική σύνθεση, τα νευρωνικά δίκτυα μπορούν να δημιουργήσουν εξόδους, των οποίων οι ακολουθίες των νοτών δεν είναι απαραίτητο να υπάρχουν στη \"συλλογή\" (corpus) του συστήματος. Μειονεκτήματα υπάρχουν στον χειρισμό του μουσικού υλικού που βασίζετε σε κάποια περιεχόμενα (context-depended) έτσι ώστε να αποδώσει στο πλαίσιο μακρινών περσμάτων, τα οποία μπορούν να αντιμετωπιστούν καλύτερα σε γενετικές γραμματικές. Για εφαρμογές αλγοριθμικής σύνθεσης, τα Νευρωνικά Δίκτυα χρησιμοποιούνται συχνά στο πλαίσιο των υβριδικών συστημάτων.\n Γενετικοί Αλγόριθμοι και Νευρωνικά Δίκτυα στην δόμηση μουσικών και ηχητικών σημάτων. (Artificial life) Machine learning and Data mining biological neural networks SuperCollider: NeuralNet SuperCollider-NatureToolkit (L-system Libray) Genetic Algorithms in designing audiovisual materials. Neural Algorithms and AI. Machine Learning, Deep Learning, Big data, Tensor Flow, Keras, Chainer. Some Machine Learning Resources: SuperCollider Classes and UGens In the Quarks: MathLib Multiupleauthors: Συμπεριλαμβάνει τα MarkovSet και FuzzySet classes περισσότερη υποστήριξη μαθηματικών για μήτρες (math support for matrices) και πολλά άλλα. ContextSnake /Gerhard Nierhaus, Alberto de Campo: A Markov pattern with variable context depth KDTree DanStowell: a data structure for faster search through a large set of multidimensional feature vectors (e.g., useful for concatenative synthesis (concatenating short samples of recorded sound). KMeans Dan Stowell: basic unsupervised clustering algorithm (Unsupervised learning) NatureToolkit Batuhan Bozkurt’s GA, L-systems, και Cellular Automata του Batuhan Bozkurt. Υπάρχουν επίσης έργα με Γενετικό Αλγόριθμο (GA) από τους Fredrik Olofsson, Dan Stowell, Matthew Yee-King. Dan Stowell’s MCLDUGens (inthesc3-plugins,http://sourceforge.net/projects/sc3-plugins) contain some server side learning algorithms: SOMTrain self-organizing map (data dimensionality reduction tool) GaussClass Gaussian classifier. Chris Kiefer and Nick Collins NeuralNet class, ένα πρόγραμμα που επιταχύνει την εκμάθηση: 7 http://ck13.net/?page_id=35 Ο Chris Kiefer δημιούργσε μία κλάσση για τα CTRNNs: Continuous-Time Recurrent Neural Networks Απο τον Collins - website: http://www.sussex.ac.uk/Users/nc81/code.html#SC Reinforcement learning classes, such as for the SARSA (state-action-reward-state-action) algorithm Επίσης, στην SCMIR Library: GMM Gaussian Mixture Model (relies on provided external program) NaiveBayes MarkovModel another implementation, fixed order PPMC Prediction by Partial Match algorithm C; a variable order Markov Model Υπάρχουν μερικές εκδόσεις αλγορίθμων μηχανικής μάθησης (Machine Learning) που είναι ενσωματωμένες στο UGens σύνθεσης, όπως το KmeansToBPSet1 στα SLUGens, ή το MarkovSynth από τον Batuhan Bozkurt. Η μηχανική μάθηση είναι ένα ευρύ πεδίο και υπάρχουν αλληλεπικαλύψεις με άλλους αλγόριθμους, όπως πληροφορίες θεωρητικών σχέσεων μεταξύ αλγορίθμων που έχουν εκπαιδευτεί με σύμβολα όπως MarkovModels και αλγόριθμοι πρόβλεψης / συμπίεσης όπως η Γραμμική Προγνωστική Κωδικοποίηση ή η Lempel-Ziv (στο Quark redSys από τον Fredik Olofsson, είναι εφαρμογές πολλών αλγορίθμων συμπίεσης). (Collins)  Artificial intelligence Η \"Τεχνιτή Νοημοσύνη\" περιλαμβάνει μια ποικιλία διαδικασιών για διαφορετικά tasks. Προγράμματα όπως το \"ELIZA\" ή το γνωστό \"Turing test\" εγείρουν το ζήτημα του ορισμού του όρου \"intelligence\" \"νοημοσύνη\".\nΟ Alan Turing ανέπτυξε μια εικονική εγκατάσταση για να αξιολογήσει την έξυπνη συμπεριφορά ενός υπολογιστή. Στην αρχή των σκέψεών του, σχεδίασε ένα παιχνίδι στο οποίο ένα άτομο πρόκειται να μαντέψει το φύλο δύο άλλων συνομιλητών.\nSwarm Algorithms  Συλλογική Συμπεριφορά   Η συμπεριφορά των σμήνων  Μαθηματικά μοντέλα για την προσομοίωση και την εκτέλεση της συμπεριφοράς.\nΤρεις βασικοί κανόνες\n Ακολουθήστε την ίδια κατεύθυνση με τους γείτονές σας Μείνετε κοντά στους γείτονές σας Αποφύγετε τις συγκρούσεις με τους γείτονές σας  Αλγόριθμοι ελέγχου\nSwarm Music\nΕκπαιδευτικά σεμινάρια\nΤο έργο του Tim Blackwell για τη μουσική Swarm\nΤο μοντέλο βασίζεται στον διαχωρισμό, την ευθυγράμμιση και τη συνοχή. Ο διαχωρισμός σημαίνει ότι κάθε πτηνό πρέπει να κατευθυνθεί έτσι ώστε να αποφευχθεί η πρόσκρουση μεταξύ τους ή με το περιβάλλον. Η ευθυγράμμιση κάθε πτηνού κινείται σε παρόμοιο μονοπάτι λαμβάνοντας τη μέση τιμή των κεντρικών πτηνών. Η συνοχή διατηρεί το σμήνος μαζί, καθώς κάθε πτηνό κατευθύνεται προς τη μέση θέση των κεντρικών πτηνών.\nΟ Blackwell δημιούργησε έναν παρόμοιο αλγόριθμο ο οποίος παραμετροποιούσε μια μηχανή κοκκώδους σύνθεσης, δημιουργώντας σε ήχο την κίνηση του σμήνους σε σχέση με τον χρόνο.(Husbands 2007 22)\nLive electronics improvisation  Mουσικά ή / και αισθητικά κίνητρα. Σύντομη ανάλυση των βασικών συνιστωσών του συστήματος, της διεπαφής χρήστη και των τεχνικών παραγωγής ήχου. Αξιολόγηση της αισθητικής ποιότητας των αποτελεσμάτων και περιγραφή της βελτίωσης και επέκτασης του συστήματος.  Περιλαμβάνει: computer synthesis techniques, hardware and software interface design.\nListening: Musica Elettronica Viva (MEV)\nListening: Boris \u0026 Merzbow Boiler Room Tokyo Live Set\nListening: AMM The Great Hall Laminal, 1982\nMusical Interfaces\n Midi Keyboards/instruments GUIs Microcontrolers Sensors Microcomputers  "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/soundtheory/",
	"title": "Sound theory basics",
	"tags": [],
	"description": "",
	"content": "chapter 1 Sound maths and physics Simple interface of a synth\nsource: A waveform (simple or complex)\narguments of a source i.e periodic oscillators\n frequency: (the cycles per second (Hz)),   phase: starts at 0 means sine, starts at 1 means cosine   amplitude: the distance between the top and the bottom of a wave.   Envelope: the shape of the sound intensity i.e attack time (the starting point of an envelope measured in milliseconds),  sustain level(intesity, measured in deciBels)  To generate a sound you can experiment in the SuperCollider environment.\nOn SuperCollider you can play a SinOsc UGEN as an audio rate sine wavetable oscillator. SinOsc uses the same implementation as Osc except that its table is fixed to be a sine wave made of 8192 samples.\nExample source and envelope:\n//SuperCollider WorkSpace ( { var env = Env([0, 1, 0.5, 1, 0], [0.01, 0.5, 0.02, 0.5]); SinOsc.ar(470) * EnvGen.kr(env, doneAction: 2) }.play )  Simple engineering tools\n delay (temporal shift on the order of ms), eq (frequency spicific amplifier), compressor (automatic gain control)  Example SC:\nDelayL.ar(in: 0, maxdelaytime: 0.2, delaytime: 0.2, mul: 1, add: 0)//Simple delay line with linear interpolation Compander.ar(in: 0, control: 0, thresh: 0.5, slopeBelow: 1, slopeAbove: 1, clampTime: 0.01, relaxTime: 0.1, mul: 1, add: 0)//Compressor, expander, limiter, gate, ducker BPeakEQ.ar(in, freq: 1200, rq: 1, db: 0, mul: 1, add: 0)//Parametric equalizer  "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/tuning_scales/",
	"title": "Κλίμακες και Χορδίσματα",
	"tags": [],
	"description": "",
	"content": "chapter 1 Scales Circle of fiths is the relationship among the 12 tones of the chromatic scale, their corresponding key signatures, and the associated major and minor keys.\nCircles of Fifths\nOther Tunings and Scales\n Intervals (διαστήματα)  Pythagorian set\nΤα σφυριά του Πυθαγόρα περιέχουν μια σειρά απο τόνικότητες που σχετίζονται μεταξύ τους. Σε αυτή τη σειρά κυριαρχούν οι οκτάβες (2/1), οι πέμπτες (3/2) και οι τέταρτες (4/3). Η πέμπτη και η τέταρτη αν πολλαπλασιαστούν μεταξύ τους θα φτιάξουν την οκτάβα (3/2*4/3=2/1), και αν διαιρεθούν ((3/2)/(4/3)=9/8) τον τόνο (9/8).\nVisualisation of a signal\nsee more here:\nHarmonograph-A Visual Guide to The Mathematics of Music\nand here:\nLissajous curve\n// ===================================================================== // SuperCollider Workspace // ===================================================================== s.boot s = Server.internal; s.boot; /* In the Stethoscope's GUI up right menu choose X/Y (\u0026quot;Lissajous curve\u0026quot; frequencies of the vertical and horizontal sinusoidal inputs, respectively) (left and right channels). See more on SC-Help: Classes |GUI-\u0026gt;Views-\u0026gt;ScopeView */ //440 = A (La) {SinOsc.ar([440, 440*81/64, 440*3/2])}.scope // pythagorean tuning: see leimma halftone of 256/243 between its major third (81/64) and the perfect fourth (4/3) as well as between major seventh and the dominant. // C major scale halftones (E to F and B to C) // C to Ab = 261.6 * 8/5 (8:5 minor sixth) = 418.56 // C to G# = 261.6 * 5/4 * 5/4 (2 major thirds) = 408.75 //The point is, A-flat and G-sharp are different pitches. //261.6*9/8*9/8*9/8*9/8*9/8*9/8 (6 major second) (octave) = 530.338156... //Bach's master work \u0026quot;The Well-Tempered Clavier\u0026quot; //261.6*2/1 (octave) = 523.2 // A chord with 3 notes (1, 3, 5) {SinOsc.ar([440, 440*5/4, 440*3/2])}.scope // (1,3M,5) with Major third {SinOsc.ar([440, 440*6/5, 440*3/2])}.play // (1,3m,5) with Minor third // {SinOsc,ar([440, 440*5/3])}.scope // major sixth interval //other ratios 1/1-\u0026gt;unison 2/1-\u0026gt;octave 3/2-\u0026gt;perfect fifth 4/3-\u0026gt;perfect fourth 5/4-\u0026gt;major third 5/3-\u0026gt;major sixth 6/5-\u0026gt;minor third 9/8-\u0026gt;tone 15/8-\u0026gt;diatonic seventh 16/15-\u0026gt;semitone 81/64-\u0026gt;major third pythagorean  Scales in SuperCollider\n( a = Scale.aeolian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.augmented; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.augmented2; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.bartok; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.chinese; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.chromatic; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.chromatic24; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.diminished; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.diminished2; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.dorian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.egyptian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.enigmatic; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.harmonicMajor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.harmonicMinor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexAeolian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexDorian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexMajor6; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexMajor7; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexPhrygian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexSus; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hindu; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hungarianMinor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.indian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.ionian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.locrian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.lydian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.major; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.majorPentatonic; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.melodicMajor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.melodicMinor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.melodicMinorDesc; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.minor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.minorPentatonic; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.mixolydian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.phrygian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.phrygian(\\pythagorean); a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.prometheus; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.scriabin; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.superLocrian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.whole; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ] Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; )  Tunings\n// ===================================================================== // SuperCollider Workspace // ===================================================================== /* BA 181802 Tunings */ Tuning.directory Scale.directory t = Tuning.pythagorean; t = Tuning.et12; t = Tuning.lu; t = Tuning.vallotti t = Tuning.young t = Tuning.perret t = Tuning.choose; //choose from tunings stored in the library //~scale = Scale.major(t).tuning.name; t.semitones; // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ] t.ratios; // [ 1, 1.0594630943591, 1.1224620483089, 1.1892071150019, etc. ] Pbind(\\scale, Scale.harmonicMinor(t), \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; //Create new Tuning t = Tuning.new((0..11).collect(_ * (2.61803398875 ** (1/12))), 2.061803398875, \u0026quot;GlodenRatio ET12\u0026quot;); Pbind(\\scale, Scale.major(t), \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play;  "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/logicalex/",
	"title": "Logical Expressions",
	"tags": [],
	"description": "",
	"content": "chapter 1 SN Symbolic notations in SuperCollider Supercollider Book\n// Logical/boolean notations/Expressions =true or false= 10==10 // equal to =\u0026gt;true... 10 !=15 // not equal to 10\u0026gt;5 // greater than 10\u0026lt;14 // less than 10 \u0026gt;= 10 // greater than or equal to 10 \u0026lt;= 10 // lees than or equal to 11.odd // it is odd 10.even // it is even 10.isInteger // it is integer 10.129.isFloat // it is float 1.odd.and(2.even) // both conditions 1.odd.or(1.even) // either condition  examples\nif(10==10, {\u0026quot;10 is equal to 10\u0026quot;}, {\u0026quot;false\u0026quot;}); if((1\u0026lt;20).and(1.isInteger), {\u0026quot;1 is less than 20\u0026quot;}, {\u0026quot;false\u0026quot;});  see more here\n"
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/",
	"title": "Code Examples",
	"tags": [],
	"description": "",
	"content": "Chapter 2 SuperCollider examples of Sound Synthesis techniques and Algorithmic Composition.\n"
},
{
	"uri": "https://vasileios.github.io/dss/introduction/notation/",
	"title": "Notation",
	"tags": [],
	"description": "",
	"content": "chapter 1 Notation MIDI\nThe lowest note musicians use is C-1, which has the MIDI number 0. The number 12 = C0, 24 = C1, 36 = C2, 48 = C3, 60 = C4 (which is middle C on the piano, remember this one), and so on. A 440 is above middle C so it is 69.\n60, 62, 63, 60, 66\nFrequencies\nIt is the number of cycles (per second) of a periodic wave.\nThe human range: 20-20000Hz\nΠίνακας συχνοτήτων\nNotes Frequency (Hz)\n A1... 55.00, 110.00, 220.00, 440.00, 880.00, etc A#1... 58.27, 116.54, 233.08, 466.16, 932.32 etc B1... 61.74, 123.48, 246.96, 493.92, 987.84, etc C1... 32.70, 65.41, 130.82, 261.64, 523.28, 1046.56, etc C#1... 34.65, 69.30, 138.60, 277.20, 554.40, 1108.80, etc D1... 36.71, 73.42, 146.84, 293.68, 587.36, 1174.72, etc  D#1... 38.89, 77.78, 155.56, 311.12, 622.24, 1244.48, etc E1... 41.20, 82.41, 164.82, 329.64, 659.28, 1318.56, etc F1... 43.65, 87.31, 174.62, 349.24, 698.48, 1396.96, etc F#1... 46.25, 92.50, 185.00, 370.00, 740.00, 1480.00 etc G1... 49.00, 98.00, 196.00, 392.00, 784.00, 1568.00, etc  G#1... 51.91, 103.83, 207.66, 415.32, 830.64, 1661.28, etc  261.62, 293.66, 311.13, 261.62, 370;\nHexadecimal\n16 symbols\n(0-9, A-F)\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n0000003C, 0000003E, 0000003F, 0000003C, 00000042\nBinary\n00111100, 00111110, 00111111, 00111100 01000010\nPitch class method\nC4, D4, Eb4, C4, F#4\n"
},
{
	"uri": "https://vasileios.github.io/dss/introduction/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": "chapter 1 Glossary Mathematics\npremise a statement that is assumed to be true.\npolynomial function is an expression consisting of variables (also called indeterminates) and coefficients, that i nvolves only the operations of addition, subtraction, multiplication, and non-negative integer exponents of variables (Wiki, see more here)\nPhysics\nfrequency the number of times that a wave, especially a light, sound, or radio wave, is produced within a particular period, especially one second.\namplitude the distance between the top and the bottom of a wave.\nwave superposition (systems theory) - superposition principle, see also Rolling motion,- is when a wave traversing the same space with other waves. (the sum of the amplitudes of any individual wave)\nComputing-SC-sound synthesis\nfunction lamda calculus\nSC Function a = { [100, 200, 300].choose };\nSC Event An Event is a SC Environment with a 'play' method. An Event specifies an action to be taken in response to a -play message.\nSC Pattern creates a Stream that iterates an array.\nSC Stream Streams represent sequences of values that are obtained one at a time.\nSC Pbind The Event Pattern Class Pbind connects specific patterns with specific names. Consult its help page for details.\nwavetable is a table with the amplitude values of a signal\nMusic\nmotet Form of polyphonic vocal music (12th century)\n"
},
{
	"uri": "https://vasileios.github.io/dss/introduction/references/",
	"title": "References",
	"tags": [],
	"description": "",
	"content": "Chapter 1 References Cope, David. 2000. The Algorithmic Composer. Madison, Wis: A-R Editions.\nDean, Roger. and McLean, Alex (eds.) 2018. The Oxford Handbook of Algorithmic Music. Oxford University Press.\nFarnell, Andy. 2010. Designing Sound. Cambridge, Mass: The MIT Press.\nGutowitz, Howard, ed. 1991. Cellular Automata: Theory and Experiment. 1 edition. Cambridge, Mass: The MIT Press.\nHoltzman, Steven. 1981. Generative Grammars for Music Composition. Computer Music Journal, Vol.5, No.1, pp. 51-64. The MIT Press.\nHusbands, Phil, Peter Copley, Alice Eldridge, and James Mandelis. 2007. ‘An Introduction to Evolutionary Computing for Musicians’. In Evolutionary Computer Music, 1–27. Springer, London. https://doi.org/10.1007/978-1-84628-600-1_1.\nΛώτης, Θ., Διαμαντόπουλος, Τ. 2015. Μουσική πληροφορική και μουσική με υπολογιστές. Εκδόσεις Κάλλιπος. [ηλεκτρ. βιβλ.] Αθήνα:Σύνδεσμος Ελληνικών Ακαδημαϊκών.\nMiranda, Eduardo R., and John Al Biles. 2007. Evolutionary Computer Music. Springer Science \u0026 Business Media.\nMiranda, E. 2002. Computer Sound Design, Second Edition: Synthesis techniques and programming (2 edition). Amsterdam: Focal Press.\nNierhaus, Gerhard. 2008. Algorithmic Composition: Paradigms of Automated Music Generation. 2009 edition. Wien ; New York: Springer.\nRoads, Curtis. 1996. The Computer Music Tutorial. Edition Unstated edition. Cambridge, Mass: The MIT Press.\nRoads, Curtis. 2004. Microsound. PAP/CDR edition. Cambridge, Mass.: The MIT Press.\nSethares, William A. 2004. Tuning, Timbre, Spectrum, Scale. 2nd edition. London: Springer.\nTolonen, T., Välimäki, V., and Karjalainen, M. 1998. Evaluation of Modern Sound Synthesis Methods. HUT.\nTrautmann, Lutz, and Rudolf Rabenstein. 2012. Digital Sound Synthesis by Physical Modeling Using the Functional Transformation Method. Springer Science \u0026 Business Media.\nSites  http://doc.sccode.org/ http://supercollider.github.io/tutorials/ http://chuck.cs.princeton.edu/doc/language/ http://chuck.cs.princeton.edu/doc/learn/ https://www.gnu.org/software/emacs/manual/ https://guides.github.com https://ccrma.stanford.edu/~blackrse/algorithm.html https://dictionary.cambridge.org/dictionary/english/algorithm http://digicult.it/digimag/issue-055/athanasius-kircher-arca-musarithmica-and https://www.youtube.com/watch?v=9Zdg6Ec4mVw https://www.npmjs.com/package/mozart-dice-game http://doc.sccode.org/Classes/Shaper.html http://doc.sccode.org/Classes/Wavetable.html http://doc.sccode.org/Browse.html#UGens%3EGranularSynthesis https://www.youtube.com/watch?v=MotG3XI2qSs http://chuck.cs.princeton.edu/release/ http://chuck.cs.princeton.edu/doc/learn/tutorial.html http://chuck.cs.princeton.edu/doc/program/ugen.html http://www.johncage.org/reunion/ https://www.youtube.com/watch?v=iPgwF3G5i4k https://getchip.com https://www.raspberrypi.org https://community.dur.ac.uk/nick.collins/teaching/supercollider/advanced/ machinelearningresources.scd https://composerprogrammer.com/researchml.html https://luuma.net/code https://www.cc.gatech.edu/~turk/bio_sim/articles/genetic_algorithm.pdf http://www.kylegann.com/histune.html https://stephenhammer.com/2010/05/tuning-recipe/ http://tonalsoft.com/monzo/55edo/55edo.htm http://casfaculty.case.edu/ross-duffin/why-i-hate-vallotti-or-is-it-young/5-why-i-hate-vallotti-or-is-it-young/sarabande-in-g-minor-vallotti/  SuperCollider Tutorials: https://composerprogrammer.com/teaching/supercollider/sctutorial/tutorial.html https://ccrma.stanford.edu/~ruviaro/texts/A_Gentle_Introduction_To_SuperCollider.pdf http://supercolliderbook.net\n"
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/supercollider/",
	"title": "SuperCollider",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider SuperCollider\nFrom: SuperCollider\nBasics\nSuperCollider is a platform for audio synthesis and algorithmic composition, used by musicians, artists, and researchers working with sound. It is free and open source software available for Windows, macOS, and Linux.\nSuperCollider features three major components\n scsynth, a real-time audio server, forms the core of the platform. It features 400+ unit generators (\"UGens\") for analysis, synthesis, and processing. Its granularity allows the fluid combination of many known and unknown audio techniques, moving between additive and subtractive synthesis, FM, granular synthesis, FFT, and physical modelling. You can write your own UGens in C++, and users have already contributed several hundred more to the sc3-plugins repository. sclang, an interpreted programming language. It is focused on sound, but not limited to any specific domain. sclang controls scsynth via Open Sound Control. You can use it for algorithmic composition and sequencing, finding new sound synthesis methods, connecting your app to external hardware including MIDI controllers, network music, writing GUIs and visual displays, or for your daily programming experiments. It has a stock of user-contributed extensions called Quarks. scide is an editor for sclang with an integrated help system.  Functions, arguments, variables Functions\nA Function is an expression which defines operations to be performed when it is sent the value message. In functional languages, a function would be known as a lambda expression. Function definitions are enclosed in curly brackets {}. Argument declarations, if any, follow the open bracket. Variable declarations follow argument declarations. An expression follows the declarations.\n// Functions in SuperCollider are within curly brackets (also called \u0026quot;braces\u0026quot;) {} { arg a, b, c; var d; d = a * b; c + d } //When evaluated, the function returns the value of its expression. f = { arg a, b; a + b }; f.value(4, 5).postln; f.value(10, 200).postln; f = {44.postln}; f.value // to call the function we need to get its .value  Arguments\nAn argument list immediately follows the open curly bracket of a function definition. An argument list either begins with the reserved word arg, or is contained between two vertical bars.\n\"arg\" style: { arg x = 1; .... }\nPipe style: { |x = 1| ... }\nVariables\nAssign values to variables.\nData type of variables: integer, float, string, symbol, etc...\n/* 180503 Algorithmic Composition Variables, functions */ Server.default=s=Server.local; s.boot; //Global variables //a-z a = 10; b = 20; c = 0.234521; a+b+c; d = \u0026quot;hello\u0026quot;; a = [1, 34, 55, 0.1, \u0026quot;string in a list\u0026quot;, \\symbol, pi]; // or an array with mixed types a //hit this line to see the container of a //local variables ( var v, a; v = 22; a = 33; ) v // hit this line and watch the post window a // hit this line and watch the post window - still our old \u0026quot;a\u0026quot; from above ( //You cannot evaluate local variables out of their scope of the brackets or a function. var number9; number9=9;//sets local vars, NOT global ) number9;//error: this doesnt work outside of the scope of the brackets /* ~ (tilde) global (Environmental variables) An Environment is an IdentityDictionary with additional features that allow it to serve as a 'name space' within which functions can be defined and/or evaluated. The compiler provides a shortcut syntax where ~ is a placeholder for .currentEnvironment. This makes the expression ~myvariable; equivalent to currentEnvironment.at(\\myvariable); and the expression ~myvariable = 888; equivalent to currentEnvironment.put(\\myvariable, 888); */ currentEnvironment; //run this line to the current state of the currentEnvironment //You use the currentEnvironment via the ~ sign ~myvariable= 888; //The ~ and = is a shortcut here for currentEnvironment.put(\\myvariable, 888); //You can access the variable wherever you need it by ~myvariable //environmental variable: sound example ( ~variable1 = {SinOsc.ar(MouseX.kr(400, 800, 1))}; ~variable2 = {Saw.ar(MouseY.kr(400, 800, 1))}; ~variable3 = (~variable1*~variable2); ) ( { Out.ar(0, ~variable3) }.play; ) currentEnvironment; //run this line to the current state of the currentEnvironment  General tips Find recordings folder\nthisProcess.platform.recordingsDir;  Sound synthesis techniques\nIntroduction to sound synthesis and sound design (origin, definition, procedures, application fields).\n  SuperCollider example:  Creating a sine wave  {SinOsc.ar(440, 0, 0.3)}.play    Additive synthesis  {SinOsc.ar(440, 0, 0.4)+SinOsc.ar(660, 0, 0.3)}.play;    Subtractive synthesis  ( {LPF.ar(Mix.fill(8, { SinOsc.ar(500 + 500.0.rand, 0, 0.05)}), 2900, 0.5); }.play )    Granular synthesis  SynthDef(\\granular, {|out = 0, trig = 1, dur = 0.1, sndbuf, pos = 0.2, rate = 1, pan = 0, amp = 0.4| var env, source; env = EnvGen.kr(Env.adsr, 1, doneAcion: 2); source = Out.ar(out, GrainBuf.ar(2, Impulse.kr(trig), dur, sndbuf, rate, pos, 2, pan, envbuf) * env) }).add;  Input Devices Musical gestures can be expressed through a wide range of body movements. Dozens of input devices have been developed to capture these gestures. (Roads 1996: 625)\n  Switch  Push buttons  Linear potentiometer or fader  Trackball  Joystick  Game Paddles  etc  Instrument design Bela\nCapacitive touch sensor-raspberry pi\nMPR121\n  To be continued...  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/oscillators/",
	"title": "Oscillators",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Oscillators SuperCollider Ugens From SC Help\n//Periodic Sources: Oscillators. //LF - \u0026quot;Low Frequency\u0026quot; Unit Generators. //arguments: frequency, phase, mul, add // *Stethoscope* s.boot a = Stethoscope(s,2); // 2 tracks //a = Stethoscope(s,2, 2); // change in i.e (Mic) // parabolic approximation of sine { LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); // cubic approximation of sine { LFCub.ar(LFCub.kr(LFCub.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { LFTri.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { LFSaw.ar(LFSaw.kr(LFSaw.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { Impulse.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { LFPulse.ar(LFPulse.kr(LFPulse.kr(0.2,0,0.5,8,10),0,0.5, 400,800),0,0.5,0.1) }.scope(1, zoom: 4); //etc //Band Limited Oscillators //arguments: frequency, phase, mul, add SinOsc, FSinOsc, Blip, Saw, Pulse. { SinOsc.ar(SinOsc.kr(SinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); //etc //Table Oscillators //arguments: buffer number, frequency, phase, mul, add Osc, COsc, VOsc, VOsc3 - uses a buffer allocated on the server. ( b = Buffer.alloc(s, 2048, 1, bufnum: 80); b.sine1(1.0/(1..6), true, true, true); ) { Osc.ar(80, 100, 0, 0.1) }.scope(1, zoom:4); b.sine1(1.0/(1..12)); b.sine1(1.0/(1..24)); b.sine1(1.0/(1..32)); b.sine1([1.0/(1,3..12), 0].flop.flat.postln); //etc  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/aperiodicsources/",
	"title": "Noise",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Noise Generators Aperiodic Sources: Noise\n//Aperiodic Sources: Noise. //LF \u0026quot;Low Frequency\u0026quot; Noise Generators. //arguments: frequency, mul, add { LFClipNoise.ar(MouseX.kr(200, 10000, 1), 0.125) }.scope(1); { LFPar.ar(LFClipNoise.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.scope(1, zoom:8); //Broad Spectrum Noise Generators //arguments: mul, add { ClipNoise.ar(0.2) }.scope(1); { WhiteNoise.ar(0.2) }.scope(1); { PinkNoise.ar(0.4) }.scope(1); { BrownNoise.ar(0.2) }.scope(1); { GrayNoise.ar(0.2) }.scope(1); // Impulse Noise Generators //Dust, Dust2 //arguments: density, mul, add { Dust.ar(MouseX.kr(1,10000,1), 0.4) }.scope(1, zoom:4); //etc //Chaotic Noise Generators //Crackle //arguments: chaosParam, mul, add { Crackle.ar(MouseX.kr(1,2), 0.5) }.scope(1);  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/filters/",
	"title": "Filters",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Filters Filters in SuperCollider\n// Filters //Low Pass, High Pass, Band Pass see more on Help //arguments: in, freq, mul, add { LPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.scope(1); { HPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.scope(1); // Resonant Low Pass, High Pass, Band Pass //arguments: in, freq, rq, mul, add { RLPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1); { RHPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1); // Resonz - resonant band pass filter with uniform amplitude //arguments: in, freq, rq, mul, add // modulate frequency { Resonz.ar(WhiteNoise.ar(0.5), XLine.kr(1000,8000,10), 0.05) }.scope(1); //Ringz - ringing filter. //arguments: in, frequency, ring time, mul, add { Ringz.ar(Dust.ar(3, 0.3), 2000, 2) }.scope(1, zoom:4); //NonLinear Filters // a signal with impulse noise. { Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1); // after applying median filter { Median.ar(3, Saw.ar(500, 0.1) + Dust2.ar(100, 0.9)) }.scope(1); // a signal with impulse noise. { Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1); // after applying slew rate limiter { Slew.ar(Saw.ar(500, 0.1) + Dust2.ar(100, 0.9),1000,1000) }.scope(1); //Formant Filter - Formlet - A filter whose impulse response is similar to a FOF grain. { Formlet.ar(Impulse.ar(MouseX.kr(2,300,1), 0, 0.4), 800, 0.01, 0.1) }.scope(1, zoom:4); // Klank - resonant filter bank //arguments: `[ frequencies, amplitudes, ring times ], mul, add { Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/distortion/",
	"title": "Distortion",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Distorion // Distortion { SinOsc.ar(300, 0, 0.2) }.scope(1); { SinOsc.ar(300, 0, 0.2).abs }.scope(1); { SinOsc.ar(300, 0, 0.2).max(0) }.scope(1); { SinOsc.ar(300, 0).squared * 0.2 }.scope(1); { SinOsc.ar(300, 0).cubed * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).distort * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).softclip * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).clip2(1) * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).fold2(1) * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.scope(1); // waveshaping by phase modulating a 0 Hz sine oscillator ( { var in; in = SinOsc.ar(300, 0, MouseX.kr(0.1,8pi,1)); SinOsc.ar(0, in, 0.2); // 0 Hz sine oscillator }.scope(1); ) //Shaper - input is used to look up a value in a table. //Chebyshev polynomials are typically used to fill the table. s.sendMsg(\\b_alloc, 80, 1024); // allocate table // fill with chebyshevs s.listSendMsg([\\b_gen, 80, \\cheby, 7] ++ {1.0.rand2.squared}.dup(6)); { Shaper.ar(80, SinOsc.ar(600, 0, MouseX.kr(0,1))) * 0.3; }.scope(1); s.listSendMsg([\\b_gen, 80, \\cheby, 7] ++ {1.0.rand2.squared}.dup(6)); s.listSendMsg([\\b_gen, 80, \\cheby, 7] ++ {1.0.rand2.squared}.dup(6));  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/delays/",
	"title": "Delays",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Delays //Delays and Buffer UGens DelayN, DelayL, DelayC - simple delays N - no interpolation L - linear interpolation C - cubic interpolation arguments: in, maximum delay time, current delay time, mul, add ( // Dust randomly triggers Decay to create an exponential // decay envelope for the WhiteNoise input source { z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar); DelayN.ar(z, 0.1, 0.1, 1, z); // input is mixed with delay via the add input }.scope(1, zoom: 4) ) // CombN, CombL, CombC - feedback delays //arguments: in, maximum delay time, current delay time, echo decay time, mul, add // used as an echo. { CombN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.scope(1, zoom:4); // Comb used as a resonator. The resonant fundamental is equal to // reciprocal of the delay time. { CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1); { CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1); { CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1); // with negative feedback: { CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1); { CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1); { CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1); { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/100, 1/100, 3) }.play; { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/200, 1/200, 3) }.play; { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/300, 1/300, 3) }.play; { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/400, 1/400, 3) }.scope(1, zoom:4);  Another example\n// Sound Sample Delay b = Buffer.read(s, Platform.resourceDir +/+ \u0026quot;sounds/a11wlk01.wav\u0026quot;); // loop is true { var signal; var delaytime = MouseX.kr(0.000022675, 1); // from a sample to 1 s signal = PlayBuf.ar(1, b.bufnum, BufRateScale.kr(b.bufnum), loop:1); x = DelayN.ar(signal, 0.6, delaytime); // try replacing with CombN (with 0 decayTime) (signal + x).dup }.play  //etc\n"
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/buffers/",
	"title": "Buffers",
	"tags": [],
	"description": "",
	"content": "chapter 2 Buffers/playback Buffers and Sound Files\nTo do sample playback and manipulation, for streaming files off disk, for recording and wavetables and many other processes, it is necessary to handle memory buffers on the Server.\nBuffer read (server, path, startFrame: 0, numFrames: -1, action, bufnum) Allocate a buffer and immediately read a soundfile into it.\n//PlayBuf - buffer playback //arguments: numChannels, buffer number, rate, trigger, start pos, loop // read sound b = Buffer.read(s, Platform.resourceDir +/+ \u0026quot;sounds/a11wlk01.wav\u0026quot;); // loop is true { PlayBuf.ar(1,b, BufRateScale.kr(b), loop:1) }.scope(1); //add a Sine oscillator { SinOsc.ar(800 + (700 * PlayBuf.ar(1,b, BufRateScale.kr(b), loop:1)),0,0.3) }.scope(1);  //Use of local variables inside scope\n//another way to read and play a sound ( var path, buffer; path = Platform.resourceDir +/+ \u0026quot;sounds/a11wlk01.wav\u0026quot;; buffer = Buffer.read(s, path); SynthDef(\\bufferC, { | out = 0, bufnum| Out.ar( out, PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), loop:1.0) ) }).add; x = Synth(\\bufferC, [\\out, 0, \\bufnum, buffer]); //play at half rate x = Synth(\\bufferC, [\\out, 0, \\bufnum, buffer.bufnum, \\rate, 0.5]); )  //another example\n( p = Platform.resourceDir +/+ \u0026quot;sounds/a11wlk01.wav\u0026quot;; b = Buffer.read(s, p); SynthDef(\\bufferC,{ | out=0,bufnum=0, rate=1, trigger=1, startPos=0, loop=1| Out.ar(out, Pan2.ar(PlayBuf.ar(1,bufnum, BufRateScale.kr(bufnum)*rate, trigger, BufFrames.ir(bufnum)*startPos, loop),0.0) ) }).send(s); ) Synth(\\bufferC, [\\out, 0, \\bufnum, b.bufnum]); //play at half rate Synth(\\bufferC, [\\out, 0, \\bufnum, b.bufnum, \\rate, 0.5]);  Example with GUI\n//Example with GUI controlling Synth ( var w, rateslid, trigslid, startposslid, loopslid, a; a=Synth(\\bufferC, [\\out, 0, \\bufnum, b.bufnum]); w=Window(\u0026quot;PlayBuf Example\u0026quot;,Rect(10,200,300,150)); w.front; //control positioning of new GUI elements so I don't have to think too hard about it w.view.decorator= FlowLayout(w.view.bounds); //James' shortcut slider class //100@24 means a Point of size 100 by 24 //|ez| is the same as arg ez; - the slider object is being passed into the callback action function rateslid= EZSlider(w, 250@24, \u0026quot;Rate\u0026quot;, ControlSpec(0.5, 10, 'exponential', 0.1), {|ez| a.set(\\rate,ez.value)}, 1); trigslid= EZSlider(w, 250@24, \u0026quot;Trigger\u0026quot;, ControlSpec(0, 1, 'lin', 1), {|ez| a.set(\\trigger,ez.value)}, 1); startposslid= EZSlider(w, 250@24, \u0026quot;StartPos\u0026quot;, ControlSpec(0.0, 1.0, 'lin', 0.01), {|ez| a.set(\\startPos,ez.value)}, 0); loopslid= EZSlider(w, 250@24, \u0026quot;Loop\u0026quot;, ControlSpec(0, 1, 'lin', 0.1), {|ez| a.set(\\loop,ez.value)}, 1); w.onClose_({a.free;}); )  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/spectral/",
	"title": "Spectral",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Spectral FFT-PV_Ugens\nFFT, IFFT and the phase vocoder ugens. FFT calculates the spectrum of a sound, puts it into a buffer, and outputs a trigger each time the buffer is ready to process. The PV (Phase Vocoder) UGens process the spectrum when they receive the trigger. IFFT converts the spectrum back into sound.\n// alloc a buffer for the FFT b = Buffer.alloc(s,2048,1); // read a sound c = Buffer.read(s, Platform.resourceDir +/+ \u0026quot;sounds/a11wlk01.wav\u0026quot;); ( // do nothing { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); 0.5 * IFFT(chain); }.scope(1); ) ( // pass only magnitudes above a threshold { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagAbove(chain, MouseX.kr(0.1,512,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // pass only magnitudes below a threshold { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagBelow(chain, MouseX.kr(0.1,512,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // brick wall filter. { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_BrickWall(chain, MouseX.kr(-1,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // pass random frequencies. Mouse controls how many to pass. // trigger changes the frequencies periodically { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_RandComb(chain, MouseX.kr(0,1), Impulse.kr(0.4)); 0.5 * IFFT(chain); }.scope(1); ) ( // rectangular comb filter { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_RectComb(chain, 8, MouseY.kr(0,1), MouseX.kr(0,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // freeze magnitudes { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagFreeze(chain, LFPulse.kr(1, 0.75)); 0.5 * IFFT(chain); }.scope(1); )  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/granularsynthesis/",
	"title": "Granular Synthesis",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Granular Synthesis //TGrains - granulation of a buffer //arguments: numChannels, trigger, buffer number, rate, center pos, dur, pan, amp, interpolation //see more about Granular synthesis on Help // read sound b = Buffer.read(s, Platform.resourceDir +/+ \u0026quot;sounds/a11wlk01.wav\u0026quot;); ( { var trate, dur; trate = MouseY.kr(2,200,1); dur = 4 / trate; TGrains.ar(2, Impulse.ar(trate), b, 1, MouseX.kr(0,BufDur.kr(b)), dur, 0, 0.1, 2); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(8,120,1); dur = 12 / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) // 4 channels ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(8,120,1); dur = 12 / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(4, clk, b, 1, pos, dur, pan, 0.1); }.scope(4, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(8,120,1); dur = 4 / trate; clk = Dust.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = LinExp.kr(LFTri.kr(MouseY.kr(0.1,2,1)),-1,1,8,120); dur = 12 / trate; clk = Impulse.ar(trate); pos = MouseX.kr(0,BufDur.kr(b)); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = 12; dur = MouseY.kr(0.2,24,1) / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = 100; dur = 8 / trate; clk = Impulse.kr(trate); pos = Integrator.kr(BrownNoise.kr(0.001)); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(1,400,1); dur = 8 / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)); pan = WhiteNoise.kr(0.8); TGrains.ar(2, clk, b, 2 ** WhiteNoise.kr(2), pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur; trate = MouseY.kr(2,120,1); dur = 1.2 / trate; TGrains.ar(2, Impulse.ar(trate), b, (1.2 ** WhiteNoise.kr(3).round(1)), MouseX.kr(0,BufDur.kr(b)), dur, WhiteNoise.kr(0.6), 0.1); }.scope(2, zoom: 4); ) // free sound b.free;  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/simplealgorithms/",
	"title": "Algorithmic Composition Examples",
	"tags": [],
	"description": "",
	"content": "chapter 2 Examples with Routines and Loops\n( /* Algorithmic composition paradigms BA 181502 Objective: create a sine wave and accelerate and decelarate its frequency nth times. */ fork{//this alternative syntax goes for Routine 10.do({//here goes the repetition (10 times) a = {SinOsc.ar(XLine.kr(100, 500, 4), 0, 0.4)}.play; 4.wait; a.release; b = {SinOsc.ar(XLine.kr(500, 100, 4), 0, 0.4)}.play; 4.wait; b.release; });//loop ends here }//fork (Routine) ends here )  probability-stochastic\n/* BA 181502 Stochastic example 1 Objective: Create two sounds one after the other then free one of them (probability), wait a couple of seconds to free also the remain sounds (probability). (Rolling a Dice) */ ( fork{ \u0026quot;sound 1\u0026quot;.postln; ~a = {Out.ar(0, SinOsc.ar(440, 0, 0.5))}.play; 2.wait; \u0026quot;sound 2\u0026quot;.postln; ~b = {Out.ar(1, SinOsc.ar(443, 0, 0.5))}.play; 0.11.wait; \u0026quot;dice game\u0026quot;.postln; 0.1.wait; \u0026quot;one sound is going to 'die'\u0026quot;.postln; 0.5.wait; \u0026quot;sound 1 or sound 2 is dead?\u0026quot;.postln; 0.1.wait; \u0026quot;rolling the die...\u0026quot;.postln; 6.wait; ~die = { fork{ var x = [1,2, 3, 4, 5, 6].choose.postln; // if you use .coin example below comment this line if(x\u0026gt;3,{~a.free},{~b.free}); // if you use .coin example below comment this line if(x\u0026gt;3, {\u0026quot;sound 1 is dead\u0026quot;.postln},{\u0026quot;sound 2 is dead\u0026quot;.postln}); // if you use .coin example below comment this line 4.wait; // if you use .coin example below comment this line /* There are other options to experiment with probability such as .wchoose and .coin as well. .wchoose //[440,220,3350,660].wchoose([0.5, 0.25, 0.2, 0.05]) //the second array of .wchoose, weights the options of the first array. .coin //0.5.coin //fair coin, equal chance. true or false as output //0.2.coin //unfair coin, 20% chance true //0.95.coin //unfair coin, 95% chance true */ //Comment out the bolow code to use .coin instead of .choose and don't forget to comment the above code /* var x = 0.5.coin.postln; if(x = false, {~a.free},{~b.free}); \u0026quot;sound 1 or sound 2 is dead?\u0026quot;.postln; if(x = false, {\u0026quot;sound 1 is dead\u0026quot;.postln},{\u0026quot;sound 2 is dead\u0026quot;.postln}); 4.wait; */ \u0026quot;free the remain sound_n\u0026quot;.postln; if(~a.isRunning, {~a.free}, {~b.free}); if(~b.isRunning, {~b.free}, {~a.free}); };//Sub-routine ends here }.value;// ~die ends here };//Routine ends here )  With complex sounds\n/* BA 181502 Stochastic example 2 Objective: Create two sounds one after the other, then free one of them and after a while free also the remain sounds using probability. (Rolling a Dice) */ ( fork{ \u0026quot;sound 1\u0026quot;.postln; ~a = {Out.ar([0,1], Resonz.ar(SinOsc.ar( Dust.kr(XLine.kr(10, 1500, 1500, 100, 40, 4), XLine.kr(100, 400, 400, 200)), 0, LFNoise1.kr(20)) , 440.rand, 0.7)*Saw.ar(XLine.kr(44, 20, 44, 20, 4)).dup)}.play; 0.1.wait; ~a.postln; 4.wait; \u0026quot;sound 2\u0026quot;.postln; ~b = {Out.ar([0,1], SinOsc.ar(SinOsc.ar(XLine.kr(10, 1500, 150, 10, 40, 4), 10, XLine.kr(100, 400, 400, 200)), 0, LFNoise1.kr(20)*0.6)*Saw.ar(XLine.kr(44, 20, 440, 20, 4)).dup)}.play; 0.1.wait; ~b.postln; 4.wait; \u0026quot;dice game\u0026quot;.postln; \u0026quot;one sound is going to 'die'\u0026quot;.postln; ~die = { fork{ var x = [1,2, 3, 4, 5, 6].choose.postln; if(x\u0026gt;3,{~a.free},{~b.free}); \u0026quot;sound 1 or sound 2 is dead?\u0026quot;.postln; if(x\u0026gt;3, {\u0026quot;sound 1 is dead\u0026quot;.postln},{\u0026quot;sound 2 is dead\u0026quot;.postln}); 4.wait; \u0026quot;free the remain sound_n\u0026quot;.postln; if(~a.isRunning, {~a.free}, {~b.free}); if(~b.isRunning, {~b.free}, {~a.free}); };//Sub-routine ends here }.value;// ~die ends here };//Routine ends here )  Analysing methods\n .normalizeSum  // first run the array with the message .normalizeSum and see the results [16, 1.7, 38, 4.2, 21].normalizeSum //the method .normalizeSum makes a new array which results from the division of the sum of the entries //We are going to use some maths to demonstrate how the method .normalizeSum works //firts find the result of the summation of the array [16, 1.7, 38, 4.2, 21].sum //80.9 //then add each value from the array seperately to the summation of the array \\ // and divide the result with the result of the summation of the array //the last thing to do is to substract the result of each equation by 1 i.e (-1) //Below is an equation of the method .normalizeSum with the a collection of five items [16, 1.7, 38, 4.2, 21] ( //run the code inside parentheses n = (16+([16, 1.7, 38, 4.2, 21].sum)/ 80.9); // start with the first item of the array (16) n = n-1; o = (1.7+([16, 1.7, 38, 4.2, 21].sum)/ 80.9); // then the second, o = o-1; r = (38+([16, 1.7, 38, 4.2, 21].sum)/ 80.9); // the third, and so on r = r-1; m = (4.2+([16, 1.7, 38, 4.2, 21].sum)/ 80.9); m = m-1; a = (21+([16, 1.7, 38, 4.2, 21].sum)/ 80.9); a = a-1; [n,o,r,m,a].asStream; ) // see the results on the post window and compare them with the results of the [16, 1.7, 38, 4.2, 21].normalizeSum  Using Patterns\nScales and Patterns examples\n/* BA 181602 Composing music with patterns paradigms Objective: Create sound textures while you playing a scale. Synthesis technique: (FM synthesis) */ //Midi notation s.boot ( SynthDef(\\synth01, {|out = 0, gate = 1, freq = 220, amp = 0.4, pan = 0, mod = 440, ind = 1| var env, source; env = EnvGen.kr(Env.adsr(0.01, 0.4, 0.001, 0.0, 1), gate, doneAction: 2); source = SinOsc.ar(SinOsc.ar(freq.midicps, mod*freq, ind*freq), 0, amp*env); Out.ar(out, source) //midicps convert MIDI note to cycles per second }).add; ~pattPm1 = Pseq((60..80)++(79..60)++[\\rest], 2); // Prand((0..14)++(13..0)++[\\rest], 2); ~pattPm2 = Pseq((0..14)++(13..0)++[\\rest], 2); ~pattPm3 = Pseq((1..18000), inf); Pbind( \\instrument, \\synth01, \\freq, Pseq([~pattPm1, ~pattPm2], 2), \\dur, 0.25, \\mod, ~pattPm3, \\ind, ~pattPm3, \\amp, Pseq((0.4..0.7), inf) ).play; )  Example 2 Patterns\n/* BA 181602 Composing music with patterns paradigms. Objective: a) Experiment with patterns and scales b) Change scale and duration after n time, c) play all scales, d) stop the music */ ( fork{ ~scaleS = Scale.bartok;//experiment with other scales as well. See Scale.directory ~pattP = Prand((0..17)++ [\\rest] ++ (16..0)++[\\rest], inf); ~pattD = Pn(Pgeom(0.25, 1, inf), Pgeom(1, 0.25, inf), inf); ~pattD2 = Pn(Prand([0.025, 0.34, 0.16, 1], inf), Pseq([1, 0.34, 0.56, 0.25], inf), inf); Pdef(\\first_mov1, Pbind(\\scale, ~scaleS, \\degree, ~pattP, \\dur, ~pattD)).play; \u0026quot;start with Bartok scale\u0026quot;.postln; 15.wait; Pdef(\\first_mov1).stop; \u0026quot;change to Dorian\u0026quot;.postln; ~scaleS = Scale.dorian; Pdef(\\first_mov2, Pbind(\\scale, ~scaleS, \\degree, ~pattP, \\dur, ~pattD2)).play; 14.wait; \u0026quot;now both\u0026quot;.postln; Pdef(\\first_mov1).play; 3.wait; \u0026quot;8s to close\u0026quot;.postln; 8.wait;// change this to a bigger number in case you want more Pdef(\\first_mov1).stop; Pdef(\\first_mov2).stop; \u0026quot;thats it\u0026quot;.postln; }; )  Playing with Patterns more\n/* BA 181802 Playing with Patterns Harmony Objective: Create Chord progressions */ s.boot; //Example with \\note notation simple major chords: I-V-IV-V ( ~soprano = Pbind(\\scale, Scale.major, \\note, Pseq([7, 11, 9, 11], inf)).play; ~alto = Pbind(\\scale, Scale.major, \\note, Pseq([0, 7, 5, 7], inf)).play; ~tenor = Pbind(\\scale, Scale.major, \\note, Pseq([4, 2, 5, 2], inf)).play; ~bass = Pbind(\\scale, Scale.major, \\note, Pseq([0, 7, 0, 7], inf)).play; ) //another example free style minor //Objective: Create Chord progressions with random delta time ( ~scalem = Scale.minor; ~soprano= Pseq([Pseq([5, 2, 1, 7], 1), Pseq([3, 1, 5, 4], 1)], inf).asStream; ~alto = Pseq([Pseq([3, 11, 9, 7], 1), Pseq([0, 7, 5, 7], 1)], inf).asStream; ~tenor = Pseq([Pseq([4, 2, 0, 9], 1), Pseq([2, 3, 5, 9], 1)], 1).asStream; ~bass = Pseq([Pseq([0, 7, 5, 7], 1), Pseq([0, 3, 6, 7], 1)], 1).asStream; \u0026quot;n movement\u0026quot;.postln; Pdef(\\nmove, Pbind(\\scale, ~scalem, \\note, Pn([~soprano, ~alto, ~tenor, ~bass], inf), \\dur, Pxrand([0.5, 0.75, 1, 2, 0.25, 0.15], inf))).play; //play forever ) // see also interval ratios i.e I-V-I-V7: 1/1, 3/2 etc. ~bassoContinuo = Pbind(\\freq, Pseq([440, 440*3/2, 440, 440*15/8], inf)).play //create the rest voices ~tenor = ... ~alto = ... ~soprano = ...  see more on Streams-Patterns-Events\nStreams\nData-driven\n/* BA 180205 Create data and collect Objective: Create data (an array of values i.e integers or floats), and map them to the arguments of the synth */ //Create and collect data as stream (array) //iterate over a collection ( a = 10.do{|n| n.postln; }; ) //collect items between 0-9 k = a.collect({ |item| item.rand.asStream }); // play the collection in Event pattern Pbind(\\dur, 0.09, \\degree, Pseq(k)).play; //with Array.fill s.waitForBoot{ fork{ //create a synthdef b = Buffer.read(s, Platform.resourceDir +/+ \u0026quot;sounds/a11wlk01.wav\u0026quot;); 1.wait; SynthDef(\\tgrain, {| gate = 1, trate = 1, dur = 1, rate = 1, bufdur = 1, amp = 0.5 | var source, env; env = EnvGen.kr( Env.asr, gate, doneAction: 2); source = TGrains.ar(2, Impulse.ar(trate), b, rate, BufDur.kr(b)*bufdur, dur, Dseq([-1, 1], inf), 0.1, 2); Out.ar(0, source * env * amp); }).add; 0.5.wait; // run the synth //x = Synth(\\tgrain); 0.5.wait; // create an Array of random values and set them to the synth e = Array.fill(100, { rrand(0, 20)}); e.postln; Pbind(\\instrument, \\tgrain, \\dur, Pseq(e.sqrt), \\trate, Pseq(e), \\rate, 1, \\amp, 1, \\bufdur, Pseq(e.reciprocal)).play; }; }  Kolakoski sequence\nIn mathematics, the Kolakoski sequence, sometimes also known as the Oldenburger-Kolakoski sequence,[1] is an infinite sequence of symbols {1,2} that is its own run-length encoding[2] and the prototype for an infinite family of related sequences. It was initially named after the recreational mathematician William Kolakoski (1944–97), who discussed it in 1965,[3] but subsequent research has revealed that it first appeared in a paper by Rufus Oldenburger in 1939.(Wikipedia) (https://en.wikipedia.org/wiki/Kolakoski_sequence)\n Python  # #kolakoski seq # Builds the list l as it's being #iterated through. #For each entry x of l, #appends x copies of 1 or 2, #whichever is opposite #the current last element. import argparse import random import time from pythonosc import osc_message_builder from pythonosc import udp_client client = udp_client.SimpleUDPClient(\u0026quot;127.0.0.1\u0026quot;, 57120) l=[2, -2] ##print(1,2) while True: for x in l: print(x);l+=x*[l[-1]^3] client.send_message(\u0026quot;/filter\u0026quot;, x) time.sleep(1)   SuperCollider  s.waitForBoot{ fork{ ~bufferk = Buffer.read(s, \u0026quot;/Users/sounds/kick03.wav\u0026quot;); // //remember to free the buffer later. ~buffersn = Buffer.read(s, \u0026quot;/Users/sounds/snare01Stereo.wav\u0026quot;); ~bufferhi = Buffer.read(s, \u0026quot;/Users/sounds/hihat01Stereo.wav\u0026quot;); 1.wait; SynthDef(\\kick, {| out = 0, bufnum = 0, amp = 0.3, rate = 1, cutoff = 2000 | var source; source = PlayBuf.ar(2, bufnum, BufRateScale.kr(bufnum)*rate, doneAction:2, loop:1); source = LPF.ar(source, cutoff+2000); Out.ar(out, source*amp) }).add; 0.5.wait; SynthDef(\\snare, {| out = 0, bufnum = 1, amp = 0.3, rate = 1, cutoff = 2000 | var source; source = PlayBuf.ar(2, bufnum, BufRateScale.kr(bufnum)*rate, doneAction:2, loop:1); source = LPF.ar(source, cutoff+2000); Out.ar(out, source*amp) }).add; SynthDef(\\hihat, {| out = 0, bufnum = 2, amp = 0.3, rate = 1, cutoff = 2000 | var source; source = PlayBuf.ar(2, bufnum, BufRateScale.kr(bufnum)*rate, doneAction:2, loop:1); source = LPF.ar(source, cutoff+2000); Out.ar(out, source*amp) }).add; ~kickx = Synth(\\kick, [\\out, 0, \\bufnum, ~bufferk, \\rate, 1]); 1.wait; ~snarex = Synth(\\snare, [\\out, 0, \\bufnum, ~buffersn, \\rate, 1]); 1.wait; ~hihatx = Synth(\\hihat, [\\out, 0, \\bufnum, ~bufferhi, \\rate, 1]); 1.wait; OSCdef(\\osctest, { | args | fork{ \u0026quot;rate and amp for kick:\u0026quot;.postln; ~kickx.setn(\\rate, args[1].postln, \\amp, args[1].reciprocal.postln, \\cutoff, args[1].pow(3)); 1.wait; \u0026quot;rate and amp for snare:\u0026quot;.postln; ~snarex.setn(\\rate, args[1].postln, \\amp, args[1].reciprocal.postln, \\cutoff, args[1].pow(2)); 1.wait; \u0026quot;rate and amp for hihat:\u0026quot;.postln; ~hihatx.setn(\\rate, args[1].postln, \\amp, args[1].reciprocal.postln, \\cutoff, args[1].pow(4)); }; }, '/filter' ); }; }  Scheduling Tempo\n( //create SynthDef SynthDef(\\blipClock, {|out = 0, gate = 1, freq = 440, numharm = 200, freq2 = 220, cutoff = 444, amp = 0.8, rq = 1, pan = 0 | var env, source, filter; env = EnvGen.kr(Env.perc, doneAction: 2); //\tenv = EnvGen.kr(Env.adsr(0.6, 0.3, 0.4, 1), gate, doneAction: 2); source = Mix.fill(2, {Blip.ar(SinOsc.ar(freq*2, freq2*3, freq*0.6), numharm, amp*env)+SinOsc.ar(freq, 0, amp*env)}); //\tfilter = RLPF.ar(source, cutoff, rq, amp).softclip; filter = LPF.ar(source, cutoff, amp).softclip; Out.ar(out, Pan2.ar(filter, pan))*0.4; }).add; ) //create a new Tempoclock ( ~t = TempoClock(2); // make a new tempoclock of 2 beats per second means 12bpm ~t.schedAbs(0, { | ... args |\t// start at absolute beat 0 immediately args.postln;\t// post the input arguments to our event function // (will post logical time in beats, elapsed time // in seconds of enclosing thread and this clock) Synth(\\blipClock, [\\freq, 60, \\numharm, 120.rand2, \\amp, 0.6]);// make a bleep 1.0\t// reschedules every beat }) ) ( //Scheduling tempo with Routines ~f = fork{ ~ev = Event.new( [ ~t.tempo_(4); 6.wait; ~t.tempo_(2); 6.wait; ~t.tempo_(1); 6.wait; ]).play; 12.wait; ~t.clear; }; )  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/synthesistec/",
	"title": "Sound synthesis techniques",
	"tags": [],
	"description": "",
	"content": "chapter 2 Sound synthesis techniques-methods Spectral\n Additive Phase Vocoder FFT  Abstract\n FM Waveshaping  Sampling\n Sampling Granular  Physical\n Modal Waveguide  Additive synthesis Additive synthesis is a method in which a composite waveform is formed by summing sinusoidal components, for example, harmonics of a tone, to produce a sound (Moorer 1985). In additive synthesis, three control functions are needed for every sinusoidal oscillator: the amplitude, frequency and phase of each component. In many cases the phase is left out and only the amplitude and frequency functions are used (Tolonen et al. 1998).\n/* Sound Synthesis techniques BA 181902 Objective: create complex sounds using additive synthesis technique // Additive Synthesis a+b+c+d where a to d can be frequencies or any other object such as a waveform */ // firts boot the internal server and open Freqscope and Stethoscope s = Server.internal; s.boot Stethoscope.new FreqScope.new //create harmonics of a 440Hz A note {SinOsc.ar([440, 880, 880*3/2, 1600*4/3, 2000], 0, [0.6, 0.1, 0.09, 0.08, 0.09])}.play//or .scope //Using Mix.ar, kr(). Sum an array of channels. ( //This example is from The SuperCollider Book (Wilson, 2011 p.37) { Mix.ar( Array.fill(12, {|count| var harm; harm = count + 1 * 110; // remeber precedence: count + 1, then * 110 SinOsc.ar(harm, mul: max(0, SinOsc.kr(count+1/4)) )*1/(count+1) }) )*0.7 }.play; ) //Add also different waveforms i.e sawtooth waveforms {Mix.fill(10, {SinOsc.ar(440+440.rand, 0, 0.03)}, {Saw.ar(440+440.rand, 0.01)})}.play; // a more complex sound {Mix.fill(10, {SinOsc.ar(440+640.rand, 0, 0.03)+Saw.ar(440+460.rand, 0.01)}, {Saw.ar(440+880.rand, 0.01)})}.play;  Phase Vocoder The phase vocoder was developed at Bell laboratories and was first described by Flanagan and Golden (1996). All vocoders present the input signal in a particular frequency band. Vocoders simplify the complex spectral information and reduce the amount of data needed to present the signal (Tolonen et al. 1998).\n// alloc a buffer for the FFT b = Buffer.alloc(s,2048,1); // read a sound c = Buffer.read(s, Platform.resourceDir +/+ \u0026quot;sounds/a11wlk01.wav\u0026quot;); ( // do nothing { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); 0.5 * IFFT(chain); }.scope(1); ) ( // pass only magnitudes above a threshold { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagAbove(chain, MouseX.kr(0.1,512,1)); 0.5 * IFFT(chain); }.scope(1); )  more examples on Spectral\nModulation synthesis FM synthesis (frequency modulation) is a fundamental digital sound synthesis technique employing a nonlinear oscillating function. The theory of FM was well established by the mid-twentieth century for radio frequencies. The use of FM in audio frequencies for the purpose of sound synthesis was not studied until late 60's. *John Chowing* (the inventor of FM synthesis) (Miranda 2002) at Stanford University was the first to study systematically FM synthesis. Chowing observed that complex audio spectra can be achieved with just two sinusoidal oscillators (Tolonen et al. 1998).\n/* Modulation synthesis Obective: modulate the frequency,the phase and the amplitude of a simple waveform using other waveforms as the modulators */ /*From 2009 Collins et al. Modulation Synthesis tutorial //Use MouseX and MouseY to control the modulation //Ring Modulation A straight multiplication of two signals. carrier * modulator */ { //2009 Collins et al. var carrier, modulator, carrfreq, modfreq; carrfreq= MouseX.kr(440,5000,'exponential'); modfreq= MouseY.kr(1,5000,'exponential'); carrier= SinOsc.ar(carrfreq,0,0.5); modulator= SinOsc.ar(modfreq,0,0.5); carrier*modulator; }.scope /* AM synthesis The modulation is Unipolar means always possitive (0, 1) SinOsc.ar(440, 0, 0.5) // (-0.5, 0.5) bipolar SinOsc.ar(440, 0, 0.5, 0.5) // (0, 1) unipolar */ ( { //2009 Collins et al. var carrier, modulator, carrfreq, modfreq; carrfreq= MouseX.kr(440,5000,'exponential'); modfreq= MouseY.kr(1,5000,'exponential'); carrier= SinOsc.ar(carrfreq,0,0.5); modulator= SinOsc.ar(modfreq,0,0.25, 0.25); carrier*modulator; }.scope ) // another example, One possitive one negative {SinOsc.ar(440, 0, SinOsc.ar(0.5), SinOsc.ar(0.5))}.scope // both possitive and negative {SinOsc.ar(440, 0, SinOsc.ar(0.25), 0.25)}.scope // try also a MouseX variable to control the modulation of the amplitude { var carrier, modulator, carrfreq, modfreq, modamp; carrfreq= MouseX.kr(440,5000,'exponential'); modfreq= MouseY.kr(1,5000,'exponential'); modamp = MouseX.kr(0.1, 1, 'exponential'); carrier= SinOsc.ar(carrfreq,0,0.5); modulator= SinOsc.ar(modfreq,0,SinOsc.ar(modamp), SinOsc.ar(modamp)); carrier*modulator; }.scope /* Fm synthesis (frequency modulation) is a technique of changing the timbre of a waveform by modulating its frequency. \u0026quot;John Chowning was the first to study FM synthesis until late 60's\u0026quot; (Tolonen et al. 1998). */ ( var synth; synth= {| carrfreq=440, modfreq=1, moddepth=0.01| SinOsc.ar(carrfreq + MouseX.kr(moddepth, 5000, 'exponential')*SinOsc.ar(MouseY.kr(modfreq, 10000, 'exponential')),0,0.25) }.scope; ) // control the carrfreq as well ( var synth; synth= {| carrfreq=440, modfreq=1, moddepth=0.01| SinOsc.ar(MouseX.kr(carrfreq, 10000, 'exponential') + MouseX.kr(moddepth, 5000, 'exponential')*SinOsc.ar(MouseY.kr(modfreq, 10000, 'exponential')),0,0.25) }.scope; ) //Create a window with sliders to control the frequency modulation (Collins 2009 et al. sc_tutorials) ( var w, carrfreqslider, modfreqslider, moddepthslider, synth; w=Window(\u0026quot;frequency modulation\u0026quot;, Rect(100, 400, 400, 300)); w.view.decorator = FlowLayout(w.view.bounds); synth= {arg carrfreq=440, modfreq=1, moddepth=0.01; SinOsc.ar(carrfreq + (moddepth*SinOsc.ar(modfreq)),0,0.25) }.scope; carrfreqslider= EZSlider(w, 300@50, \u0026quot;carrfreq\u0026quot;, ControlSpec(20, 5000, 'exponential', 10, 440), {|ez| synth.set(\\carrfreq, ez.value)}); w.view.decorator.nextLine; modfreqslider= EZSlider(w, 300@50, \u0026quot;modfreq\u0026quot;, ControlSpec(1, 5000, 'exponential', 1, 1), {|ez| synth.set(\\modfreq, ez.value)}); w.view.decorator.nextLine; moddepthslider= EZSlider(w, 300@50, \u0026quot;moddepth\u0026quot;, ControlSpec(0.01, 5000, 'exponential', 0.01, 0.01), {|ez| synth.set(\\moddepth, ez.value)}); w.front; ) //Phase Modulation ( { //2009 Collins et al. var modf, ind; modf= MouseX.kr(1,440, 'exponential'); ind=MouseY.kr(0.0,10.0); SinOsc.ar(440, SinOsc.ar(modf,0,modf*ind),0.25) }.scope )  Waveshaping synthesis Waveshaping synthesis - nonlinear distortion\nWaveshaping synthesis is a simple sound synthesis method using a nonlinear shaping function to modify the input signal (Tolonen et al. 1998)\n/* BA 182202 Waveshaping examples Objective: create a wavetable and shape the waveform */ s.boot; //Fill this buffer with a series of Chebyshev polynomials, see more on Help-\u0026gt;Buffer b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])}); ( { Shaper.ar( b, SinOsc.ar(300, 0, Line.kr(0,1,6)+Saw.ar(304, Line.kr(0, 1, 6))), 0.5 ) }.scope; ) b.free; //another example with sine wave series //Fill this buffer with a series of sine wave partials using specified frequencies, amplitudes, and initial phases. b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg([1,0,1,1,0,1])}); //see also sine2 and 3 ( { Shaper.ar( b, SinOsc.ar(300+305.rand, 0, LFNoise2.kr(0+0.15)+Saw.ar(304+30.7.rand, LFNoise2.kr(0.15))), 0.5 ) }.scope; ) b.free; //another example b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])}); //check also with other tables. //Combine tables //b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])}); //b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg([1,0,1,1,0,1])}); ( { Shaper.ar( b, SinOsc.ar(300+305.rand, 0, LFNoise2.kr(0+0.15.rand)+Saw.ar(304+307.rand, LFNoise2.kr(0.15.rand)))+PinkNoise.ar(0.1.rand), 0.5 ) }.scope; ) b.free;  Sampling Sampling synthesis is a method in which recordings of relatively short sounds are played back (Roads 1995). Digital sampling instruments, also called samplers, are typically used to perform pitch shifting, looping, or other modification of the original sound signal (Borin et al. 1997b) (Tolonen et al. 1998)\n/*Using Buffers with Sound Files Buffer has another class method called 'read', which reads a sound file into memory, and returns a Buffer object. Using the UGen PlayBuf, we can play the file. */ // read a soundfile b = Buffer.read(s, \u0026quot;sounds/a11wlk01.wav\u0026quot;); // now play it ( x = SynthDef(\u0026quot;tutorial-PlayBuf\u0026quot;,{ arg out = 0, bufnum; Out.ar( out, PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum)) ) }).play(s,[\\bufnum, b.bufnum ]); ) x.free; b.free;  Granular synthesis Granular synthesis is a set of techniques that share a common paradigm of representing sound signals by \"sound atoms\" or grains. Granular synthesis originated from the studies by Gabor in the lates 40's (Cavaliere and Piccialli 1997; Roads 1995). In granular synthesis the sound grain can have duration ranging from one millisecond to more than a hundred milliseconds and the waveform of the grain can be a windowed sinusoid, a sampled signal, or obtained from a physics-based model of a sound production mechanism (Cavaliere and Piccialli 1997) (Tolonen et al. 1998).\n/* GrainBuf Granular synthesis with sound stored in a buffer. GrainBuf.ar(numChannels: 1, trigger: 0, dur: 1, sndbuf, rate: 1, pos: 0, interp: 2, pan: 0, envbufnum: -1, maxGrains: 512, mul: 1, add: 0) */ s.boot; ( var winenv; b = Buffer.read(s, Platform.resourceDir +/+ \u0026quot;sounds/a11wlk01-44_1.aiff\u0026quot;); // a custom envelope winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]); z = Buffer.sendCollection(s, winenv.discretize, 1); SynthDef(\\buf_grain_test, { |out, gate = 1, amp = 1, sndbuf, envbuf| var pan, env, freqdev; // use mouse x to control panning pan = MouseX.kr(-1, 1); env = EnvGen.kr( Env([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: Done.freeSelf); Out.ar(out, GrainBuf.ar(2, Impulse.kr(10), 0.1, sndbuf, LFNoise1.kr.range(0.5, 2), LFNoise2.kr(0.1).range(0, 1), 2, pan, envbuf) * env) }).add; ) // use built-in env x = Synth(\\buf_grain_test, [\\sndbuf, b, \\envbuf, -1]) // switch to the custom env x.set(\\envbuf, z) x.set(\\envbuf, -1); x.set(\\gate, 0);  more examples on Granular Synthesis\nPhysical Modeling Digital waveguide synthesis\n/* BA102002 Physical Modeling Digital waveguide synthesis: superposition of 2 waves (right going and left going waves) modal synthesis (resonant modes of vibration of acoustic systems)(vibrating systems) delay line (Using delays and filters to model the propagation of sound wave - geometry of the waveguide) mass-spring models (signals based on masses and springs) See more on: JA Laird., 2001. The Physical Modelling of Drums Using Digital Waveguides. University of Bristol and (Tolonen, et al. 1998) */ /* Instruction: Envelope (sound behaviour - time domain), Impulse (trigger), NoiseGen (texture), CombL (delay line) */ ///WaveTables //Create a table with size 512 and the amplitudes which shape the waveform. Use Sine or Chebyshev polynomial function. a = Wavetable.sineFill(512, 1.0/[1, 2, 3, 4, 5, 6]); a = Wavetable.chebyFill(513, [0, 0, 1]); a = Wavetable.chebyFill(513, [0.3, -0.8, 1.1]); a = Wavetable.sineFill(512, [0.5]); a = a.resamp1(256); a = a.as(Signal); a = a.asWavetable; // Server side s.boot; b = Buffer.loadCollection(s, a); x = b.play(loop: true); // ok sounds x.free; /// more on wavetables //load a wavetable and open the collection to a SoundFile w = SoundFile.openRead(\u0026quot;~/wavetables/WT01.aif\u0026quot;.standardizePath); // Create an array to load the data a = FloatArray.newClear(w.numFrames); w.readData(a); w.close; a.size; // resamp the table to have a pow of 2 (bigger to avoid aliassing) // in case of many diff samples choose a bigger pow of 2 a = a.resamp1(256); // Convert the array to a Signal a = a.as(Signal); a.size; // Convert it to a Wavetable a = a.asWavetable; a.size; //wavetable format is signal.size * 2 // load the collection into a buffer b = Buffer.loadCollection(s, a); //play the buffer and loop x = b.play(loop: true); x.free; //use Osc interpolating wavetable oscillator. see also VOsc3 and more on Help-\u0026gt;UGens\u0026gt;Generators\u0026gt;Deterministic //Osc.ar(table, freq, phase, mul, add) x = { LPF.ar(Osc.ar(b, MouseX.kr(440, 880)), SampleRate.ir/2-1000) }.play; s.freqscope x.free; //see Ball, TBall, Spring Ugens on Help //TBall //Example:1 // mouse x controls switch of level // mouse y controls gravity ( { var t, sf; sf = K2A.ar(MouseX.kr \u0026gt; 0.5) \u0026gt; 0; t = TBall.ar(sf, MouseY.kr(0.01, 1.0, 1), 0.01); Pan2.ar(Ringz.ar(t * 10, 1200, 0.1), MouseX.kr(-1,1)); }.play; ) //spring ( { var inforce, outforce, freq, k, d; inforce = K2A.ar(MouseButton.kr(0,1,0)) \u0026gt; 0; k = MouseY.kr(0.1, 20, 1); d = MouseX.kr(0.00001, 0.1, 1); outforce = Spring.ar(inforce, k, d); freq = outforce * 400 + 500; // modulate frequency with the force SinOsc.ar(freq, 0, 0.2) }.play; )  Creating textures with wavetables\n/* BA 182202 Sound Textures examples Objective: Experiment with table oscilators to create sound textures */ // COsc wavetable example 1: ( b = Buffer.alloc(s, 512, 1, {| buf | buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])}); { LPF.ar(COsc.ar(b.bufnum, [200.rand.postln, 1000.rand], 0.7, 0.25)*Saw.ar(440+444.rand, WhiteNoise.kr(0.7)), 4000) }.play; )  "
},
{
	"uri": "https://vasileios.github.io/dss/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://vasileios.github.io/dss/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]