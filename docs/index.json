[
{
	"uri": "https://vasileios.github.io/dss/",
	"title": "Ψηφιακη Συνθεση Ηχου",
	"tags": [],
	"description": "",
	"content": " Ψηφιακή Σύνθεση Ήχου Επιστημονικό Πεδίο: Αλγοριθμική Σύνθεση και Δόμηση Ήχου\n4 εξάμηνο Θεωρία-Εργαστήριο\nΣχολή Μουσικής και Οπτικοακουστικών Τεχνών - Ιόνιο Πανεπιστήμιο\n\u0026ldquo;Τμήμα Εθνομουσικολογίας\u0026rdquo;\n2018-2019\n"
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/",
	"title": "Code Examples",
	"tags": [],
	"description": "",
	"content": "Chapter 2 SuperCollider examples - Sound Synthesis techniques and Algorithmic Composition.\n"
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/001supercollider/",
	"title": "SuperCollider",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider SuperCollider\nFrom: SuperCollider\nBasics\nSuperCollider is a platform for audio synthesis and algorithmic composition, used by musicians, artists, and researchers working with sound. It is free and open source software available for Windows, macOS, and Linux.\nSuperCollider features three major components\n scsynth, a real-time audio server, forms the core of the platform. It features 400+ unit generators (\"UGens\") for analysis, synthesis, and processing. Its granularity allows the fluid combination of many known and unknown audio techniques, moving between additive and subtractive synthesis, FM, granular synthesis, FFT, and physical modelling. You can write your own UGens in C++, and users have already contributed several hundred more to the sc3-plugins repository. sclang, an interpreted programming language. It is focused on sound, but not limited to any specific domain. sclang controls scsynth via Open Sound Control. You can use it for algorithmic composition and sequencing, finding new sound synthesis methods, connecting your app to external hardware including MIDI controllers, network music, writing GUIs and visual displays, or for your daily programming experiments. It has a stock of user-contributed extensions called Quarks. scide is an editor for sclang with an integrated help system.  Code examples Find recordings folder\nthisProcess.platform.recordingsDir;  Sound synthesis techniques\nIntroduction to sound synthesis and sound design (origin, definition, procedures, application fields).\n  SuperCollider example:  Creating a sine wave  {SinOsc.ar(440, 0, 0.3)}.play    Additive synthesis  {SinOsc.ar(440, 0, 0.4)+SinOsc.ar(660, 0, 0.3)}.play;    Subtractive synthesis  ( {LPF.ar(Mix.fill(8, { SinOsc.ar(500 + 500.0.rand, 0, 0.05)}), 2900, 0.5); }.play )    Granular synthesis  SynthDef(\\granular, {|out = 0, trig = 1, dur = 0.1, sndbuf, pos = 0.2, rate = 1, pan = 0, amp = 0.4| var env, source; env = EnvGen.kr(Env.adsr, 1, doneAcion: 2); source = Out.ar(out, GrainBuf.ar(2, Impulse.kr(trig), dur, sndbuf, rate, pos, 2, pan, envbuf) * env) }).add;  Input Devices Musical gestures can be expressed through a wide range of body movements. Dozens of input devices have been developed to capture these gestures. (Roads 1996: 625)\n  Switch  Push buttons  Linear potentiometer or fader  Trackball  Joystick  Game Paddles  etc  Instrument design Bela\nCapacitive touch sensor-raspberry pi\nMPR121\n  To be continued...  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/002oscillators/",
	"title": "Oscillators",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Oscillators SuperCollider Ugens From SC Help\n//Periodic Sources: Oscillators. //LF - \u0026#34;Low Frequency\u0026#34; Unit Generators. //arguments: frequency, phase, mul, add  // *Stethoscope*  s.boot a = Stethoscope(s,2); // 2 tracks //a = Stethoscope(s,2, 2); // change in i.e (Mic)  // parabolic approximation of sine { LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); // cubic approximation of sine { LFCub.ar(LFCub.kr(LFCub.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { LFTri.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { LFSaw.ar(LFSaw.kr(LFSaw.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { Impulse.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { LFPulse.ar(LFPulse.kr(LFPulse.kr(0.2,0,0.5,8,10),0,0.5, 400,800),0,0.5,0.1) }.scope(1, zoom: 4); //etc  //Band Limited Oscillators  //arguments: frequency, phase, mul, add  SinOsc, FSinOsc, Blip, Saw, Pulse. { SinOsc.ar(SinOsc.kr(SinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); //etc  //Table Oscillators //arguments: buffer number, frequency, phase, mul, add Osc, COsc, VOsc, VOsc3 - uses a buffer allocated on the server. ( b = Buffer.alloc(s, 2048, 1, bufnum: 80); b.sine1(1.0/(1..6), true, true, true); ) { Osc.ar(80, 100, 0, 0.1) }.scope(1, zoom:4); b.sine1(1.0/(1..12)); b.sine1(1.0/(1..24)); b.sine1(1.0/(1..32)); b.sine1([1.0/(1,3..12), 0].flop.flat.postln); //etc  //Chaotic Noise Generators //arguments: chaosParam, mul, add  { Crackle.ar(MouseX.kr(1,2), 0.5) }.scope(1); "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/003aperiodicsources/",
	"title": "Noise",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Noise Generators Aperiodic Sources: Noise\n/Aperiodic Sources: Noise. //LF \u0026#34;Low Frequency\u0026#34; Noise Generators. //arguments: frequency, mul, add { LFClipNoise.ar(MouseX.kr(200, 10000, 1), 0.125) }.scope(1); { LFPar.ar(LFClipNoise.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.scope(1, zoom:8); //Broad Spectrum Noise Generators //arguments: mul, add { ClipNoise.ar(0.2) }.scope(1); { WhiteNoise.ar(0.2) }.scope(1); { PinkNoise.ar(0.4) }.scope(1); { BrownNoise.ar(0.2) }.scope(1); { GrayNoise.ar(0.2) }.scope(1); // Impulse Noise Generators //Dust, Dust2 //arguments: density, mul, add  { Dust.ar(MouseX.kr(1,10000,1), 0.4) }.scope(1, zoom:4); //etc  //Chaotic Noise Generators //Crackle //arguments: chaosParam, mul, add  { Crackle.ar(MouseX.kr(1,2), 0.5) }.scope(1); "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/004filters/",
	"title": "Filters",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Filters Filters in SuperCollider\n// Filters  //Low Pass, High Pass, Band Pass see more on Help //arguments: in, freq, mul, add  { LPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.scope(1); { HPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.scope(1); // Resonant Low Pass, High Pass, Band Pass //arguments: in, freq, rq, mul, add  { RLPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1); { RHPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1); // Resonz - resonant band pass filter with uniform amplitude //arguments: in, freq, rq, mul, add  // modulate frequency { Resonz.ar(WhiteNoise.ar(0.5), XLine.kr(1000,8000,10), 0.05) }.scope(1); //Ringz - ringing filter.  //arguments: in, frequency, ring time, mul, add  { Ringz.ar(Dust.ar(3, 0.3), 2000, 2) }.scope(1, zoom:4); //NonLinear Filters  // a signal with impulse noise. { Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1); // after applying median filter { Median.ar(3, Saw.ar(500, 0.1) + Dust2.ar(100, 0.9)) }.scope(1); // a signal with impulse noise. { Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1); // after applying slew rate limiter { Slew.ar(Saw.ar(500, 0.1) + Dust2.ar(100, 0.9),1000,1000) }.scope(1); //Formant Filter - Formlet - A filter whose impulse response is similar to a FOF grain.  { Formlet.ar(Impulse.ar(MouseX.kr(2,300,1), 0, 0.4), 800, 0.01, 0.1) }.scope(1, zoom:4); // Klank - resonant filter bank //arguments: `[ frequencies, amplitudes, ring times ], mul, add  { Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play; "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/005distortion/",
	"title": "Distortion",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Distorion // Distortion  { SinOsc.ar(300, 0, 0.2) }.scope(1); { SinOsc.ar(300, 0, 0.2).abs }.scope(1); { SinOsc.ar(300, 0, 0.2).max(0) }.scope(1); { SinOsc.ar(300, 0).squared * 0.2 }.scope(1); { SinOsc.ar(300, 0).cubed * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).distort * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).softclip * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).clip2(1) * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).fold2(1) * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.scope(1); // waveshaping by phase modulating a 0 Hz sine oscillator  ( { var in; in = SinOsc.ar(300, 0, MouseX.kr(0.1,8pi,1)); SinOsc.ar(0, in, 0.2); // 0 Hz sine oscillator }.scope(1); ) //Shaper - input is used to look up a value in a table. //Chebyshev polynomials are typically used to fill the table.  s.sendMsg(\\b_alloc, 80, 1024); // allocate table // fill with chebyshevs s.listSendMsg([\\b_gen, 80, \\cheby, 7] ++ {1.0.rand2.squared}.dup(6)); { Shaper.ar(80, SinOsc.ar(600, 0, MouseX.kr(0,1))) * 0.3; }.scope(1); s.listSendMsg([\\b_gen, 80, \\cheby, 7] ++ {1.0.rand2.squared}.dup(6)); s.listSendMsg([\\b_gen, 80, \\cheby, 7] ++ {1.0.rand2.squared}.dup(6)); "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/006delays/",
	"title": "Delays",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Delays //Delays and Buffer UGens DelayN, DelayL, DelayC - simple delays N - no interpolation L - linear interpolation C - cubic interpolation arguments: in, maximum delay time, current delay time, mul, add ( // Dust randomly triggers Decay to create an exponential // decay envelope for the WhiteNoise input source { z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar); DelayN.ar(z, 0.1, 0.1, 1, z); // input is mixed with delay via the add input }.scope(1, zoom: 4) ) // CombN, CombL, CombC - feedback delays //arguments: in, maximum delay time, current delay time, echo decay time, mul, add  // used as an echo. { CombN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.scope(1, zoom:4); // Comb used as a resonator. The resonant fundamental is equal to // reciprocal of the delay time. { CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1); { CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1); { CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1); // with negative feedback: { CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1); { CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1); { CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1); { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/100, 1/100, 3) }.play; { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/200, 1/200, 3) }.play; { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/300, 1/300, 3) }.play; { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/400, 1/400, 3) }.scope(1, zoom:4); //etc  //PlayBuf - buffer playback //arguments: numChannels, buffer number, rate, trigger, start pos, loop  // read sound b = Buffer.read(s, Platform.resourceDir +/+ \u0026#34;sounds/a11wlk01.wav\u0026#34;); { SinOsc.ar(800 + (700 * PlayBuf.ar(1,b, BufRateScale.kr(b), loop:1)),0,0.3) }.scope(1); // loop is true { PlayBuf.ar(1,b, BufRateScale.kr(b), loop:1) }.scope(1); "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/007spectral/",
	"title": "Spectral",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Spectral FFT-PV_Ugens\nFFT, IFFT and the phase vocoder ugens. FFT calculates the spectrum of a sound, puts it into a buffer, and outputs a trigger each time the buffer is ready to process. The PV UGens process the spectrum when they receive the trigger. IFFT converts the spectrum back into sound.\n// alloc a buffer for the FFT b = Buffer.alloc(s,2048,1); // read a sound c = Buffer.read(s, Platform.resourceDir +/+ \u0026#34;sounds/a11wlk01.wav\u0026#34;); ( // do nothing { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); 0.5 * IFFT(chain); }.scope(1); ) ( // pass only magnitudes above a threshold { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagAbove(chain, MouseX.kr(0.1,512,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // pass only magnitudes below a threshold { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagBelow(chain, MouseX.kr(0.1,512,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // brick wall filter. { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_BrickWall(chain, MouseX.kr(-1,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // pass random frequencies. Mouse controls how many to pass. // trigger changes the frequencies periodically { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_RandComb(chain, MouseX.kr(0,1), Impulse.kr(0.4)); 0.5 * IFFT(chain); }.scope(1); ) ( // rectangular comb filter { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_RectComb(chain, 8, MouseY.kr(0,1), MouseX.kr(0,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // freeze magnitudes { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagFreeze(chain, LFPulse.kr(1, 0.75)); 0.5 * IFFT(chain); }.scope(1); ) "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/008granularsynthesis/",
	"title": "Granular Synthesis",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Granular Synthesis //TGrains - granulation of a buffer //arguments: numChannels, trigger, buffer number, rate, center pos, dur, pan, amp, interpolation //see more about Granular synthesis on Help  // read sound b = Buffer.read(s, Platform.resourceDir +/+ \u0026#34;sounds/a11wlk01.wav\u0026#34;); ( { var trate, dur; trate = MouseY.kr(2,200,1); dur = 4 / trate; TGrains.ar(2, Impulse.ar(trate), b, 1, MouseX.kr(0,BufDur.kr(b)), dur, 0, 0.1, 2); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(8,120,1); dur = 12 / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) // 4 channels ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(8,120,1); dur = 12 / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(4, clk, b, 1, pos, dur, pan, 0.1); }.scope(4, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(8,120,1); dur = 4 / trate; clk = Dust.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = LinExp.kr(LFTri.kr(MouseY.kr(0.1,2,1)),-1,1,8,120); dur = 12 / trate; clk = Impulse.ar(trate); pos = MouseX.kr(0,BufDur.kr(b)); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = 12; dur = MouseY.kr(0.2,24,1) / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = 100; dur = 8 / trate; clk = Impulse.kr(trate); pos = Integrator.kr(BrownNoise.kr(0.001)); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(1,400,1); dur = 8 / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)); pan = WhiteNoise.kr(0.8); TGrains.ar(2, clk, b, 2 ** WhiteNoise.kr(2), pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur; trate = MouseY.kr(2,120,1); dur = 1.2 / trate; TGrains.ar(2, Impulse.ar(trate), b, (1.2 ** WhiteNoise.kr(3).round(1)), MouseX.kr(0,BufDur.kr(b)), dur, WhiteNoise.kr(0.6), 0.1); }.scope(2, zoom: 4); ) // free sound b.free; "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/009synthesistec/",
	"title": "Sound synthesis techniques",
	"tags": [],
	"description": "",
	"content": "chapter 2 Sound synthesis techniques-methods Spectral\n Additive Phase Vocoder FFT  Abstract\n FM Waveshaping  Sampling\n Sampling Granular  Physical\n Modal Waveguide  Additive synthesis Additive synthesis is a method in which a composite waveform is formed by summing sinusoidal components, for example, harmonics of a tone, to produce a sound (Moorer 1985). In additive synthesis, three control functions are needed for every sinusoidal oscillator: the amplitude, frequency and phase of each component. In many cases the phase is left out and only the amplitude and frequency functions are used (Tolonen et al. 1998).\n/* Sound Synthesis techniques BA 181902 Objective: create complex sounds using additive synthesis technique // Additive Synthesis a+b+c+d where a to d can be frequencies or any other object such as a waveform */ // firts boot the internal server and open Freqscope and Stethoscope  s = Server.internal; s.boot Stethoscope.new FreqScope.new //create harmonics of a 440Hz A note  {SinOsc.ar([440, 880, 880*3/2, 1600*4/3, 2000], 0, [0.6, 0.1, 0.09, 0.08, 0.09])}.play//or .scope //Using Mix.ar, kr(). Sum an array of channels.  ( //This example is from The SuperCollider Book (Wilson, 2011 p.37) { Mix.ar( Array.fill(12, {|count| var harm; harm = count + 1 * 110; // remeber precedence: count + 1, then * 110 \tSinOsc.ar(harm, mul: max(0, SinOsc.kr(count+1/4)) )*1/(count+1) }) )*0.7 }.play; ) //Add also different waveforms i.e sawtooth waveforms  {Mix.fill(10, {SinOsc.ar(440+440.rand, 0, 0.03)}, {Saw.ar(440+440.rand, 0.01)})}.play; // a more complex sound  {Mix.fill(10, {SinOsc.ar(440+640.rand, 0, 0.03)+Saw.ar(440+460.rand, 0.01)}, {Saw.ar(440+880.rand, 0.01)})}.play;  Phase Vocoder The phase vocoder was developed at Bell laboratories and was first described by Flanagan and Golden (1996). All vocoders present the input signal in a particular frequency band. Vocoders simplify the complex spectral information and reduce the amount of data needed to present the signal (Tolonen et al. 1998).\n// alloc a buffer for the FFT b = Buffer.alloc(s,2048,1); // read a sound c = Buffer.read(s, Platform.resourceDir +/+ \u0026#34;sounds/a11wlk01.wav\u0026#34;); ( // do nothing { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); 0.5 * IFFT(chain); }.scope(1); ) ( // pass only magnitudes above a threshold { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagAbove(chain, MouseX.kr(0.1,512,1)); 0.5 * IFFT(chain); }.scope(1); )  more examples on Spectral\nModulation synthesis FM synthesis (frequency modulation) is a fundamental digital sound synthesis technique employing a nonlinear oscillating function. The theory of FM was well established by the mid-twentieth century for radio frequencies. The use of FM in audio frequencies for the purpose of sound synthesis was not studied until late 60's. *John Chowing* (the inventor of FM synthesis) (Miranda 2002) at Stanford University was the first to study systematically FM synthesis. Chowing observed that complex audio spectra can be achieved with just two sinusoidal oscillators (Tolonen et al. 1998).\n/* Modulation synthesis Obective: modulate the frequency,the phase and the amplitude of a simple waveform using other waveforms as the modulators */ /*From 2009 Collins et al. Modulation Synthesis tutorial //Use MouseX and MouseY to control the modulation //Ring Modulation A straight multiplication of two signals. carrier * modulator */ { //2009 Collins et al. var carrier, modulator, carrfreq, modfreq; carrfreq= MouseX.kr(440,5000,\u0026#39;exponential\u0026#39;); modfreq= MouseY.kr(1,5000,\u0026#39;exponential\u0026#39;); carrier= SinOsc.ar(carrfreq,0,0.5); modulator= SinOsc.ar(modfreq,0,0.5); carrier*modulator; }.scope /* AM synthesis The modulation is Unipolar means always possitive (0, 1) SinOsc.ar(440, 0, 0.5) // (-0.5, 0.5) bipolar SinOsc.ar(440, 0, 0.5, 0.5) // (0, 1) unipolar */ ( { //2009 Collins et al. var carrier, modulator, carrfreq, modfreq; carrfreq= MouseX.kr(440,5000,\u0026#39;exponential\u0026#39;); modfreq= MouseY.kr(1,5000,\u0026#39;exponential\u0026#39;); carrier= SinOsc.ar(carrfreq,0,0.5); modulator= SinOsc.ar(modfreq,0,0.25, 0.25); carrier*modulator; }.scope ) // another example, One possitive one negative  {SinOsc.ar(440, 0, SinOsc.ar(0.5), SinOsc.ar(0.5))}.scope // both possitive and negative  {SinOsc.ar(440, 0, SinOsc.ar(0.25), 0.25)}.scope // try also a MouseX variable to control the modulation of the amplitude  { var carrier, modulator, carrfreq, modfreq, modamp; carrfreq= MouseX.kr(440,5000,\u0026#39;exponential\u0026#39;); modfreq= MouseY.kr(1,5000,\u0026#39;exponential\u0026#39;); modamp = MouseX.kr(0.1, 1, \u0026#39;exponential\u0026#39;); carrier= SinOsc.ar(carrfreq,0,0.5); modulator= SinOsc.ar(modfreq,0,SinOsc.ar(modamp), SinOsc.ar(modamp)); carrier*modulator; }.scope /* Fm synthesis (frequency modulation) is a technique of changing the timbre of a waveform by modulating its frequency. \u0026#34;John Chowning was the first to study FM synthesis until late 60\u0026#39;s\u0026#34; (Tolonen et al. 1998). */ ( var synth; synth= {| carrfreq=440, modfreq=1, moddepth=0.01| SinOsc.ar(carrfreq + MouseX.kr(moddepth, 5000, \u0026#39;exponential\u0026#39;)*SinOsc.ar(MouseY.kr(modfreq, 10000, \u0026#39;exponential\u0026#39;)),0,0.25) }.scope; ) // control the carrfreq as well  ( var synth; synth= {| carrfreq=440, modfreq=1, moddepth=0.01| SinOsc.ar(MouseX.kr(carrfreq, 10000, \u0026#39;exponential\u0026#39;) + MouseX.kr(moddepth, 5000, \u0026#39;exponential\u0026#39;)*SinOsc.ar(MouseY.kr(modfreq, 10000, \u0026#39;exponential\u0026#39;)),0,0.25) }.scope; ) //Create a window with sliders to control the frequency modulation (Collins 2009 et al. sc_tutorials)  ( var w, carrfreqslider, modfreqslider, moddepthslider, synth; w=Window(\u0026#34;frequency modulation\u0026#34;, Rect(100, 400, 400, 300)); w.view.decorator = FlowLayout(w.view.bounds); synth= {arg carrfreq=440, modfreq=1, moddepth=0.01; SinOsc.ar(carrfreq + (moddepth*SinOsc.ar(modfreq)),0,0.25) }.scope; carrfreqslider= EZSlider(w, 300@50, \u0026#34;carrfreq\u0026#34;, ControlSpec(20, 5000, \u0026#39;exponential\u0026#39;, 10, 440), {|ez| synth.set(\\carrfreq, ez.value)}); w.view.decorator.nextLine; modfreqslider= EZSlider(w, 300@50, \u0026#34;modfreq\u0026#34;, ControlSpec(1, 5000, \u0026#39;exponential\u0026#39;, 1, 1), {|ez| synth.set(\\modfreq, ez.value)}); w.view.decorator.nextLine; moddepthslider= EZSlider(w, 300@50, \u0026#34;moddepth\u0026#34;, ControlSpec(0.01, 5000, \u0026#39;exponential\u0026#39;, 0.01, 0.01), {|ez| synth.set(\\moddepth, ez.value)}); w.front; ) //Phase Modulation ( { //2009 Collins et al. var modf, ind; modf= MouseX.kr(1,440, \u0026#39;exponential\u0026#39;); ind=MouseY.kr(0.0,10.0); SinOsc.ar(440, SinOsc.ar(modf,0,modf*ind),0.25) }.scope )  Waveshaping synthesis Waveshaping synthesis - nonlinear distortion\nWaveshaping synthesis is a simple sound synthesis method using a nonlinear shaping function to modify the input signal (Tolonen et al. 1998)\n/* BA 182202 Waveshaping examples Objective: create a wavetable and shape the waveform */ s.boot; //Fill this buffer with a series of Chebyshev polynomials, see more on Help-\u0026gt;Buffer b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])}); ( { Shaper.ar( b, SinOsc.ar(300, 0, Line.kr(0,1,6)+Saw.ar(304, Line.kr(0, 1, 6))), 0.5 ) }.scope; ) b.free; //another example with sine wave series //Fill this buffer with a series of sine wave partials using specified frequencies, amplitudes, and initial phases. b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg([1,0,1,1,0,1])}); //see also sine2 and 3  ( { Shaper.ar( b, SinOsc.ar(300+305.rand, 0, LFNoise2.kr(0+0.15)+Saw.ar(304+30.7.rand, LFNoise2.kr(0.15))), 0.5 ) }.scope; ) b.free; //another example  b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])}); //check also with other tables. //Combine tables //b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])}); //b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg([1,0,1,1,0,1])});  ( { Shaper.ar( b, SinOsc.ar(300+305.rand, 0, LFNoise2.kr(0+0.15.rand)+Saw.ar(304+307.rand, LFNoise2.kr(0.15.rand)))+PinkNoise.ar(0.1.rand), 0.5 ) }.scope; ) b.free;  Sampling Sampling synthesis is a method in which recordings of relatively short sounds are played back (Roads 1995). Digital sampling instruments, also called samplers, are typically used to perform pitch shifting, looping, or other modification of the original sound signal (Borin et al. 1997b) (Tolonen et al. 1998)\n/*Using Buffers with Sound Files Buffer has another class method called \u0026#39;read\u0026#39;, which reads a sound file into memory, and returns a Buffer object. Using the UGen PlayBuf, we can play the file. */ // read a soundfile b = Buffer.read(s, \u0026#34;sounds/a11wlk01.wav\u0026#34;); // now play it \t( x = SynthDef(\u0026#34;tutorial-PlayBuf\u0026#34;,{ arg out = 0, bufnum; Out.ar( out, PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum)) ) }).play(s,[\\bufnum, b.bufnum ]); ) x.free; b.free;  Granular synthesis Granular synthesis is a set of techniques that share a common paradigm of representing sound signals by \"sound atoms\" or grains. Granular synthesis originated from the studies by Gabor in the lates 40's (Cavaliere and Piccialli 1997; Roads 1995). In granular synthesis the sound grain can have duration ranging from one millisecond to more than a hundred milliseconds and the waveform of the grain can be a windowed sinusoid, a sampled signal, or obtained from a physics-based model of a sound production mechanism (Cavaliere and Piccialli 1997) (Tolonen et al. 1998).\n/* GrainBuf Granular synthesis with sound stored in a buffer. GrainBuf.ar(numChannels: 1, trigger: 0, dur: 1, sndbuf, rate: 1, pos: 0, interp: 2, pan: 0, envbufnum: -1, maxGrains: 512, mul: 1, add: 0) */ s.boot; ( var winenv; b = Buffer.read(s, Platform.resourceDir +/+ \u0026#34;sounds/a11wlk01-44_1.aiff\u0026#34;); // a custom envelope winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]); z = Buffer.sendCollection(s, winenv.discretize, 1); SynthDef(\\buf_grain_test, { |out, gate = 1, amp = 1, sndbuf, envbuf| var pan, env, freqdev; // use mouse x to control panning  pan = MouseX.kr(-1, 1); env = EnvGen.kr( Env([0, 1, 0], [1, 1], \\sin, 1), gate, levelScale: amp, doneAction: Done.freeSelf); Out.ar(out, GrainBuf.ar(2, Impulse.kr(10), 0.1, sndbuf, LFNoise1.kr.range(0.5, 2), LFNoise2.kr(0.1).range(0, 1), 2, pan, envbuf) * env) }).add; ) // use built-in env x = Synth(\\buf_grain_test, [\\sndbuf, b, \\envbuf, -1]) // switch to the custom env x.set(\\envbuf, z) x.set(\\envbuf, -1); x.set(\\gate, 0);  more examples on Granular Synthesis\nPhysical Modeling Digital waveguide synthesis\n/* BA102002 Physical Modeling Digital waveguide synthesis: superposition of 2 waves (right going and left going waves) modal synthesis (resonant modes of vibration of acoustic systems)(vibrating systems) delay line (Using delays and filters to model the propagation of sound wave - geometry of the waveguide) mass-spring models (signals based on masses and springs) See more on: JA Laird., 2001. The Physical Modelling of Drums Using Digital Waveguides. University of Bristol and (Tolonen, et al. 1998) */ /* Instruction: Envelope (sound behaviour - time domain), Impulse (trigger), NoiseGen (texture), CombL (delay line) */ ///WaveTables //Create a table with size 512 and the amplitudes which shape the waveform. Use Sine or Chebyshev polynomial function.  a = Wavetable.sineFill(512, 1.0/[1, 2, 3, 4, 5, 6]); a = Wavetable.chebyFill(513, [0, 0, 1]); a = Wavetable.chebyFill(513, [0.3, -0.8, 1.1]); a = Wavetable.sineFill(512, [0.5]); a = a.resamp1(256); a = a.as(Signal); a = a.asWavetable; // Server side s.boot; b = Buffer.loadCollection(s, a); x = b.play(loop: true); // ok sounds x.free; /// more on wavetables //load a wavetable and open the collection to a SoundFile w = SoundFile.openRead(\u0026#34;~/wavetables/WT01.aif\u0026#34;.standardizePath); // Create an array to load the data a = FloatArray.newClear(w.numFrames); w.readData(a); w.close; a.size; // resamp the table to have a pow of 2 (bigger to avoid aliassing) // in case of many diff samples choose a bigger pow of 2  a = a.resamp1(256); // Convert the array to a Signal a = a.as(Signal); a.size; // Convert it to a Wavetable a = a.asWavetable; a.size; //wavetable format is signal.size * 2  // load the collection into a buffer  b = Buffer.loadCollection(s, a); //play the buffer and loop x = b.play(loop: true); x.free; //use Osc interpolating wavetable oscillator. see also VOsc3 and more on Help-\u0026gt;UGens\u0026gt;Generators\u0026gt;Deterministic //Osc.ar(table, freq, phase, mul, add) x = { LPF.ar(Osc.ar(b, MouseX.kr(440, 880)), SampleRate.ir/2-1000) }.play; s.freqscope x.free; //see Ball, TBall, Spring Ugens on Help //TBall //Example:1 // mouse x controls switch of level // mouse y controls gravity ( { var t, sf; sf = K2A.ar(MouseX.kr \u0026gt; 0.5) \u0026gt; 0; t = TBall.ar(sf, MouseY.kr(0.01, 1.0, 1), 0.01); Pan2.ar(Ringz.ar(t * 10, 1200, 0.1), MouseX.kr(-1,1)); }.play; ) //spring  ( { var inforce, outforce, freq, k, d; inforce = K2A.ar(MouseButton.kr(0,1,0)) \u0026gt; 0; k = MouseY.kr(0.1, 20, 1); d = MouseX.kr(0.00001, 0.1, 1); outforce = Spring.ar(inforce, k, d); freq = outforce * 400 + 500; // modulate frequency with the force  SinOsc.ar(freq, 0, 0.2) }.play; )  Creating textures with wavetables\n/* BA 182202 Sound Textures examples Objective: Experiment with table oscilators to create sound textures */ // COsc wavetable example 1:  ( b = Buffer.alloc(s, 512, 1, {| buf | buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])}); { LPF.ar(COsc.ar(b.bufnum, [200.rand.postln, 1000.rand], 0.7, 0.25)*Saw.ar(440+444.rand, WhiteNoise.kr(0.7)), 4000) }.play; ) "
},
{
	"uri": "https://vasileios.github.io/dss/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://vasileios.github.io/dss/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]