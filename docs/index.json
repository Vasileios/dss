[
{
	"uri": "https://vasileios.github.io/dss/introduction/",
	"title": "Εισαγωγή",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Αλγοριθμικη Συνθεση Αποσπάσματα κυρίως απο το βιβλίο \"Algorithmic Composition: Paradigms of Automated Music Generation\" (Nierhaus 2009).\nΟ αλγόριθμος είναι:\n \"- Ένα σύνολο μαθηματικών οδηγιών που πρέπει να ακολουθηθούν για τον υπολογισμό μιας απάντησης σε ένα μαθηματικό πρόβλημα. Μια συστηματική διαδικασία που παράγει - σε ένα πεπερασμένο αριθμό βημάτων την απάντηση σε μια ερώτηση ή τη λύση ενός προβλήματος. (κυρίως για υπολογιστές) ένα σύνολο κανόνων που πρέπει να ακολουθηθούν για να επιλυθεί ένα συγκεκριμένο πρόβλημα\". (Nierhaus 2009 2)  Αλγοριθμική σύνθεση\n\"Ο όρος παραπέμπει πως οι κανόνες αυτοί προέρχονται κυρίως από τον χώρο των μαθηματικών, με τη μορφή απλών αριθμητικών πράξεων ή περισσότερο σύνθετων δομών όπως για παράδειγμα στατιστικά μοντέλα, σύνολα, συναρτήσεις, γεωμετρίες κ.λπ. Σε άλλες περιπτώσεις ακολουθούνται διαφορετικές προσεγγίσεις οι οποίες προέρχονται από ένα πλήθος διαφορετικών πεδίων: εξελικτικά βιολογικά μοντέλα και γενετικοί αλγόριθμοι, ειδικές γραμματικές, συστήματα μηχανικής μάθησης και τεχνητής νοημοσύνης, κυτταρικά αυτόματα κ.ο.κ.\" (Λώτης \u0026 Διαμαντόπουλος 2015 254)\n"
},
{
	"uri": "https://vasileios.github.io/dss/",
	"title": "Ψηφιακη Συνθεση Ηχου",
	"tags": [],
	"description": "",
	"content": " Ψηφιακή Σύνθεση Ήχου Επιστημονικό Πεδίο: Αλγοριθμική Σύνθεση και Δόμηση Ήχου\n4 εξάμηνο Θεωρία-Εργαστήριο\nΣχολή Μουσικής και Οπτικοακουστικών Τεχνών - Ιόνιο Πανεπιστήμιο\n\u0026ldquo;Τμήμα Εθνομουσικολογίας\u0026rdquo;\n2018-2019\n"
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/",
	"title": "Code Examples",
	"tags": [],
	"description": "",
	"content": "Chapter 2 SuperCollider examples of Sound Synthesis techniques and Algorithmic Composition.\n"
},
{
	"uri": "https://vasileios.github.io/dss/introduction/history/",
	"title": "Ιστορία",
	"tags": [],
	"description": "",
	"content": "chapter 1 Ψηφιακή σύνθεση Ήχου Ιστορια Synthesis techniques and programming.\nΚατά τη διάρκεια του περασμένου αιώνα, η ηλεκτρική ενέργεια διαπέρασε σταδιακά τον κόσμο του ήχου. Η μουσική πλέον ακούγεται τώρα μέσω των ηχείων. Αλλά, πέρα από την αναπαραγωγή, η ηλεκτρική τεχνολογία επίσης έφερε ριζικά νέους πόρους για την παραγωγή νέων ήχων και μουσικής.\nΧρειάστηκε αρκετός χρόνος για τον μουσικό κόσμο να συνειδητοποιήσει τις δυνατότητες αυτών των πόρων. Ακόμη, για πολλά χρόνια, ο Edgard Varese προσπάθησε να πείσει τους ερευνητές και τα ιδρύματα να δούν τα πλεονέκτημα που προσφέρειη επιστήμη και η τεχνολογία για την ανάπτυξη μηχανών παραγωγής ήχου - μόνο στο τέλος της ζωής του ήταν σε θέση να συνθέσει τη μουσική με τη χρήση μαγνητοταινίας (tape music and music concrete) καιέτσι να κάνει τα πρώτα βήματα της μουσικής με υπολογιστή (Computer Music).\nΟ Γιάννης Ξενάκης χρησιμοποίησε τις δυνατότητες του υπολογιστή για αρκετές από τις συνθέσεις του και ο Pierre Boulez ξεκίνησε το IRCAM, ένα ινστιτούτο αφιερωμένο στη μουσική έρευνα και τη δημιουργία και η οποία χρησιμοποιεί ως επί το πλείστον ψηφιακά εργαλεία. Η ποπ μουσική δεν θα μπορούσε ποτέ να εξελιχθεί χωρίς τον ηλεκτρονικό εξοπλισμό και τα διάφορα μουσικά σχήμάτα δε θα μποούσαν να ανάπτυξουν το δικό του 'ήχο'. Όλα αυτά περιλαμβάνονται στην έρευνα για τον ηχητικό σχεδιασμό.\nΈτσι οι νέες δυνατότητες έχουν ήδη μεγάλη επιρροή στη μουσική σύνθεση. Η εξερεύνηση αυτών των δυνατότητων συνεχίζονται καιαυτή είναι η πιο συναρπαστική πρόκληση για τους μουσικούς σήμερα.\nΗ προηγμένη ηλεκτρονική τεχνολογία για τον ήχο είναι από καιρό «αναλογική». Άνοιξε νέες δυνατότητες - για παράδειγμα, με τη συγκεκριμένη μουσική 'musique concr'ete', που αποτελείται από ηχογραφημένους ακουστικούς ήχους και 'ηλεκτρονική μουσική », καταφεύγοντας σε ήχους που παράγονται ηλεκτρονικά. Ωστόσο, mastering αναλογική τεχνολογία απαιτούσαν αριστοτεχνική μαγεία, οπότε οι μουσικοί χρησιμοποίησαν γενικά έτοιμες δυνατότητες και δεν ανάπτυξαν τις δικές τους. Επιπλέον, ο εξοπλισμός είχε την τάση να είναι ασταθής και να αλλάζει και γρήγορα κατέστη άνευ αντικειμένου.\nΑπό τα τέλη της δεκαετίας του 1950, η ψηφιακή τεχνολογία του ήχου, που εισήγαγε ο Max Mathews, σταδιακά αντικατέστησε την αναλογική τεχνολογία. Η ψηφιακή κωδικοποίηση φέρνει ακρίβεια, σταθερότητα και αναπαραγωγικότητα στην ηχητική σύνθεση και επεξεργασία και επιτρέπει στον ήχο έλεγχο. Ο μουσικός επωφελείται από τα απεριόριστες δυνατότητες του υπολογιστή. Όπως λέει συχνά ο François Bayle, ο υπολογιστής είναι όχι ένα εργαλείο, αλλά περισσότερο μοιάζει με ένα εργαστήριο - ο καθένας μπορεί να το διαμορφώσει για να καθορίσει τον δικό του κόσμο, να σχεδιάσει τα δικά του timbres, να κατασκευάσει τα δικά του εργαλεία, τόσο διανοητικά όσο και υλικά, διαμορφωμένα σύμφωνα με τις κλίσεις του κάθε ατόμου. Αυτό που διακυβεύεται εδώ είναι πολύ σημαντικό - το ψηφιακό domain επιτρέπει την επέκταση του ελέγχου της σύνθεσης στο επίπεδο του ίδιου του ήχου, όχι μόνο συνθέτοντας με ήχους, αλλά συνθέτοντας τους ίδιους τους ήχους.\nΗ δυνατότητες της δημιουργίας ήχων μέσω των υπολογιστών πρέπει να ερευνηθούν.\nMax Mathews and Music-N. The First digital synthesiser.\nThough computer music is at the edge of the avant-garde today, its roots go back to 1957, when Mathews wrote the first version of \"Music,\" a program that allowed an IBM 704 mainframe computer to play a 17-second composition.\nΕπίσης, ο John Chowning δεν ανέπτυξε μόνο μια ισχυρή νέα μέθοδο για τον ήχο (FM), δημιούργησε και νέα και πειστικά μουσικά έργα και ενθάρρυνε το κοινό στην κατανόηση του μουσικού ήχου και της αντίληψής του.\nΌσο συναρπαστική, να είναι αυτή η φάση διερεύνησης είναι και απαιτητική και πολλοί μουσικοί δεν επιθυμούν να αφιερώσουν πολύ χρόνο για να εξερευνήσουν και να αναπτύξουν νέες δυνατότητες. Τα ισχυρά λογισμικά σύνθεσης είναι κάπως δύσκολο να χρησιμοποιηθούν απο τους μουσικούς γιατί πολλά απο αυτά δεν ίναι πολύ φιλικά προς το χρήστη.\nΌταν ψηφιακά συστήματα ήχου σε πραγματικό χρόνο εμφανίστηκαν πριν από περίπου 25 χρόνια, πολλοί μουσικοί νόμιζαν ότι μπορούσαν να χρησιμοποιήσουν χειριστήρια σε πραγματικό χρόνο, το αυτί τους και τη διαίσθησή τους να επιλέξουν μεταξύ των δυνατοτήτων που προσφέρονται για τον ήχο. Αυτό ήταν εν πολλοίς όμως αυταπάτη.\nΠεριστρέφοντας τα κουμπιά, ή παίζοντας με τα χειριστήρια είναι δύσκολο να έχει κάποιος συνθέτης το αποτέλεσμα που θα ήθελε. Για παράδειγμα, όπως η χειραγώγηση του κύβου του Rubik χωρίς στρατηγικές μπορεί να μη λυθεί ποτέ.\nΠρόβημα απαξίωσης\nΟι δυνατότητες τωω συστήματα που λειτουργούσαν σε πραγματικό χρόνο, μπορούσαν να χρησιμοποιούν μόνο σε πραγματικό χρόνο απο τους μουσικούς και τις περισσότερες φορές οι σχεδιαστές που τα είχαν δημιουργήσει δεν είχαν συγκεκριμένες αισθητικές απαιτήσεις. Αύτο έκανε πολλούς να αποξιώσουν αυτά τα συστήματα και να μή τα εξελίξουν.\nΕπίσης, πολλοί συνθέτες τείναν να χρησιμοποιούν έτοιμους ήχους και έτοιμα προγράμματα, αντί να δουλεύουν για την ποιότητα του ήχου.\nΚάποιος μπορεί να δει μια αισθητική παλινδρόμηση - οι μουσικοί δεν μπορούσαν να αντισταθούν στον πειρασμό τις αναπαραγωγής και σύνθεσης σε πραγματικό χρόνο και κατέληγαν να καταφεύγουν σε παρόμοιες λύσεις οι οποίες σύντομα έγιναν στερεότυπα και κλισέ.\nΕπιπλέον, η λειτουργία σε πραγματικό χρόνο χρειαζόταν επεξεργαστές ειδικού σκοπού χρησιμοποιώντας την πιο προηγμένη μικροηλεκτρονική τεχνολογία, αλλά αυτή η τεχνολογία εξελίχθηκε τόσο γρήγορα ώστε η διάρκεια ζωής αυτών των συστημάτων ήταν μόνο λίγα χρόνια, και τα μουσικά έργα θα έπρεπε να προσαρμοστούν στα νεότερα συστήματα.\nΤέτοιες προσαρμογές ήταν δαπανηρές και συχνά απαγορευτικές. Πολλά μουσικά έργα δεν μπορούν πλέον να παιχτουν λόγω αυτού του προβλήματος.\nΟι τεχνολογία σήμερα\nΕυτυχώς, οι συνθήκες εργασίας για τη μουσική με υπολογιστές σήμερα είναι πολύ πιο ευνοϊκές. Οι προσωπικοί υπολογιστές έχουν γίνει τόσο ισχυροί που δεν χρειάζονται πλέον ειδικά κυκλώματα για να λειτουργήσουν σε πραγματικό χρόνο. Το ζήτημα αφορά μόνο το λογισμικό - είναι πολύ πιο εύκολο να χρησιμοποιηθεί απο τον έναν υπολογιστή στον άλλο ή σε κάποιο μελλοντικό μοντέλο. Σε αντίθεση με τη δεκαετία του 1960 και τη δεκαετία του 1970, όπου μόνο τα μεγάλα ιδρύματα μπορούσαν να παράσχουν τους πιο σύγχρονους πόρους για την ηλεκτροακουστική μουσική, σήμερα τα πιο προηγμένα εργαλεία προγραμματισμού και σύνθεσης καθώς καιεπεξεργασίας του ήχου μπορούν να παραχθούν απο προσωπικούς υπολογίστες. Οι μουσικοί μπορούν - και πρέπει - να συμμετέχουν στην επιλογή και προσαρμογή των εργαλεία αυτων με βάση τα συγκεκριμένα γούστα και τους σκοπούς τους.\nΚάποιος μπορεί να επωφεληθεί από την τεχνογνωσία που αναπτύχθηκε, μια τεχνογνωσία που μπορεί να μεταδοθεί εύκολα σε ψηφιακή μορφή αλλά και σε μορφή κώδικα - για παράδειγμα όσον αφορά τις «συνταγές», δηλαδή τα δεδομένα που απαιτούνται για τη σύνθεση ορισμένων ήχων που είναι δύσκολο να επιτευχθούν - αυτό είναι ένα μεγάλο πλεονέκτημα.\nComputer Sound Design\nMiranda. E. 2002.\n"
},
{
	"uri": "https://vasileios.github.io/dss/introduction/soundtheory/",
	"title": "Sound theory basics",
	"tags": [],
	"description": "",
	"content": "chapter 1 Sound maths and physics Simple interface of a synth\nsource: A waveform (simple or complex)\narguments of a source i.e periodic oscillators\n frequency: (the cycles per second (Hz)),   phase: starts at 0 means sine, starts at 1 means cosine   amplitude: the distance between the top and the bottom of a wave.   Envelope: the shape of the sound intensity i.e attack time (the starting point of an envelope measured in milliseconds),  sustain level(intesity, measured in deciBels)  To generate a sound you can experiment in the SuperCollider environment.\nOn SuperCollider you can play a SinOsc UGEN as an audio rate sine wavetable oscillator. SinOsc uses the same implementation as Osc except that its table is fixed to be a sine wave made of 8192 samples.\nExample source and envelope:\n//SuperCollider WorkSpace ( { var env = Env([0, 1, 0.5, 1, 0], [0.01, 0.5, 0.02, 0.5]); SinOsc.ar(470) * EnvGen.kr(env, doneAction: 2) }.play )  Simple engineering tools\n delay (temporal shift on the order of ms), eq (frequency spicific amplifier), compressor (automatic gain control)  Example SC:\nDelayL.ar(in: 0, maxdelaytime: 0.2, delaytime: 0.2, mul: 1, add: 0)//Simple delay line with linear interpolation  Compander.ar(in: 0, control: 0, thresh: 0.5, slopeBelow: 1, slopeAbove: 1, clampTime: 0.01, relaxTime: 0.1, mul: 1, add: 0)//Compressor, expander, limiter, gate, ducker  BPeakEQ.ar(in, freq: 1200, rq: 1, db: 0, mul: 1, add: 0)//Parametric equalizer "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/supercollider/",
	"title": "SuperCollider",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider SuperCollider\nFrom: SuperCollider\nBasics\nSuperCollider is a platform for audio synthesis and algorithmic composition, used by musicians, artists, and researchers working with sound. It is free and open source software available for Windows, macOS, and Linux.\nSuperCollider features three major components\n scsynth, a real-time audio server, forms the core of the platform. It features 400+ unit generators (\"UGens\") for analysis, synthesis, and processing. Its granularity allows the fluid combination of many known and unknown audio techniques, moving between additive and subtractive synthesis, FM, granular synthesis, FFT, and physical modelling. You can write your own UGens in C++, and users have already contributed several hundred more to the sc3-plugins repository. sclang, an interpreted programming language. It is focused on sound, but not limited to any specific domain. sclang controls scsynth via Open Sound Control. You can use it for algorithmic composition and sequencing, finding new sound synthesis methods, connecting your app to external hardware including MIDI controllers, network music, writing GUIs and visual displays, or for your daily programming experiments. It has a stock of user-contributed extensions called Quarks. scide is an editor for sclang with an integrated help system.  Code examples Find recordings folder\nthisProcess.platform.recordingsDir;  Sound synthesis techniques\nIntroduction to sound synthesis and sound design (origin, definition, procedures, application fields).\n  SuperCollider example:  Creating a sine wave  {SinOsc.ar(440, 0, 0.3)}.play    Additive synthesis  {SinOsc.ar(440, 0, 0.4)+SinOsc.ar(660, 0, 0.3)}.play;    Subtractive synthesis  ( {LPF.ar(Mix.fill(8, { SinOsc.ar(500 + 500.0.rand, 0, 0.05)}), 2900, 0.5); }.play )    Granular synthesis  SynthDef(\\granular, {|out = 0, trig = 1, dur = 0.1, sndbuf, pos = 0.2, rate = 1, pan = 0, amp = 0.4| var env, source; env = EnvGen.kr(Env.adsr, 1, doneAcion: 2); source = Out.ar(out, GrainBuf.ar(2, Impulse.kr(trig), dur, sndbuf, rate, pos, 2, pan, envbuf) * env) }).add;  Input Devices Musical gestures can be expressed through a wide range of body movements. Dozens of input devices have been developed to capture these gestures. (Roads 1996: 625)\n  Switch  Push buttons  Linear potentiometer or fader  Trackball  Joystick  Game Paddles  etc  Instrument design Bela\nCapacitive touch sensor-raspberry pi\nMPR121\n  To be continued...  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/oscillators/",
	"title": "Oscillators",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Oscillators SuperCollider Ugens From SC Help\n//Periodic Sources: Oscillators. //LF - \u0026#34;Low Frequency\u0026#34; Unit Generators. //arguments: frequency, phase, mul, add  // *Stethoscope*  s.boot a = Stethoscope(s,2); // 2 tracks //a = Stethoscope(s,2, 2); // change in i.e (Mic)  // parabolic approximation of sine { LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); // cubic approximation of sine { LFCub.ar(LFCub.kr(LFCub.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { LFTri.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { LFSaw.ar(LFSaw.kr(LFSaw.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { Impulse.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); { LFPulse.ar(LFPulse.kr(LFPulse.kr(0.2,0,0.5,8,10),0,0.5, 400,800),0,0.5,0.1) }.scope(1, zoom: 4); //etc  //Band Limited Oscillators  //arguments: frequency, phase, mul, add  SinOsc, FSinOsc, Blip, Saw, Pulse. { SinOsc.ar(SinOsc.kr(SinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.scope(1, zoom: 4); //etc  //Table Oscillators //arguments: buffer number, frequency, phase, mul, add Osc, COsc, VOsc, VOsc3 - uses a buffer allocated on the server. ( b = Buffer.alloc(s, 2048, 1, bufnum: 80); b.sine1(1.0/(1..6), true, true, true); ) { Osc.ar(80, 100, 0, 0.1) }.scope(1, zoom:4); b.sine1(1.0/(1..12)); b.sine1(1.0/(1..24)); b.sine1(1.0/(1..32)); b.sine1([1.0/(1,3..12), 0].flop.flat.postln); //etc  //Chaotic Noise Generators //arguments: chaosParam, mul, add  { Crackle.ar(MouseX.kr(1,2), 0.5) }.scope(1); "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/tuning_scales/",
	"title": "Κλίμακες και Χορδίσματα",
	"tags": [],
	"description": "",
	"content": "chapter 1 Scales Circle of fiths is the relationship among the 12 tones of the chromatic scale, their corresponding key signatures, and the associated major and minor keys.\nCircles of Fifths\nOther Tunings and Scales\n Intervals (διαστήματα)  Pythagorian set\nΤα σφυριά του Πυθαγόρα περιέχουν μια σειρά απο τόνικότητες που σχετίζονται μεταξύ τους. Σε αυτή τη σειρά κυριαρχούν οι οκτάβες (2/1), οι πέμπτες (3/2) και οι τέταρτες (4/3). Η πέμπτη και η τέταρτη αν πολλαπλασιαστούν μεταξύ τους θα φτιάξουν την οκτάβα (3/2*4/3=2/1), και αν διαιρεθούν ((3/2)/(4/3)=9/8) τον τόνο (9/8).\nVisualisation of a signal\nsee more here:\nHarmonograph-A Visual Guide to The Mathematics of Music\nand here:\nLissajous curve\n// ===================================================================== // SuperCollider Workspace // ===================================================================== s.boot s = Server.internal; s.boot; /* In the Stethoscope\u0026#39;s GUI up right menu choose X/Y (\u0026#34;Lissajous curve\u0026#34; frequencies of the vertical and horizontal sinusoidal inputs, respectively) (left and right channels). See more on SC-Help: Classes |GUI-\u0026gt;Views-\u0026gt;ScopeView */ //440 = A (La) {SinOsc.ar([440, 440*81/64, 440*3/2])}.scope // pythagorean tuning: see leimma halftone of 256/243 between its major third (81/64) and the perfect fourth (4/3) as well as between major seventh and the dominant. // C major scale halftones (E to F and B to C) // C to Ab = 261.6 * 8/5 (8:5 minor sixth) = 418.56 // C to G# = 261.6 * 5/4 * 5/4 (2 major thirds) = 408.75 //The point is, A-flat and G-sharp are different pitches. //261.6*9/8*9/8*9/8*9/8*9/8*9/8 (6 major second) (octave) = 530.338156... //Bach\u0026#39;s master work \u0026#34;The Well-Tempered Clavier\u0026#34; //261.6*2/1 (octave) = 523.2  // A chord with 3 notes in diatonic tuning (1, 3, 5)  {SinOsc.ar([440, 440*5/4, 440*3/2])}.scope // (1,3M,5) Diatonic tuning {SinOsc.ar([440, 440*6/5, 440*3/2])}.play // (1,3m,5) Minor third diatoniic {SinOsc,ar([440, 440*5/3])}.scope // magor sixth 1/1-\u0026gt;unison 2/1-\u0026gt;octave 3/2-\u0026gt;perfect fifth 4/3-\u0026gt;perfect fourth 5/4-\u0026gt;major third diatonic 5/3-\u0026gt;magor sixth diatonic 6/5-\u0026gt;minor third diatonic 9/8-\u0026gt;tone 15/8-\u0026gt;diatonic seventh 16/15-\u0026gt;semitone 81/64-\u0026gt;major third pythagorean  Scales in SuperCollider\n( a = Scale.aeolian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.augmented; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.augmented2; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.bartok; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.chinese; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.chromatic; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.chromatic24; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.diminished; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.diminished2; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.dorian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.egyptian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.enigmatic; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.harmonicMajor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.harmonicMinor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexAeolian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexDorian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexMajor6; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexMajor7; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexPhrygian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hexSus; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hindu; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.hungarianMinor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.indian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.ionian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.locrian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.lydian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.major; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.majorPentatonic; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.melodicMajor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.melodicMinor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.melodicMinorDesc; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.minor; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.minorPentatonic; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.mixolydian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.phrygian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.phrygian(\\pythagorean); a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.prometheus; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.scriabin; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.superLocrian; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; ) ( a = Scale.whole; a.degrees; // [ 0, 2, 4, 5, 7, 9, 11 ] a.semitones; // [ 0, 2, 4, 5, 7, 9, 11 ] a.cents; // [ 0, 200, 300, 500, 700, 900, 1100 ] a.ratios; // [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]  Pbind(\\scale, a, \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; )  Tunings\n// ===================================================================== // SuperCollider Workspace // ===================================================================== /* BA 181802 Tunings */ Tuning.directory Scale.directory t = Tuning.pythagorean; t = Tuning.et12; t = Tuning.lu; t = Tuning.vallotti t = Tuning.young t = Tuning.perret t = Tuning.choose; //choose from tunings stored in the library //~scale = Scale.major(t).tuning.name;  t.semitones; // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ] t.ratios; // [ 1, 1.0594630943591, 1.1224620483089, 1.1892071150019, etc. ]  Pbind(\\scale, Scale.harmonicMinor(t), \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; //Create new Tuning  Tuning.new((0..11).collect(_ * (2.61803398875 ** (1/12))), 2.061803398875, \u0026#34;GlodenRatio ET12\u0026#34;); Pbind(\\scale, Scale.major(t), \\degree, Pseq((0..7) ++ (6..0) ++ [\\rest], 1), \\dur, 0.25).play; "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/logicalex/",
	"title": "Logical Expressions",
	"tags": [],
	"description": "",
	"content": "chapter 1 LE Logical Expressions in SuperCollider\nLogical expressions =true or false= 10==10 // equal to =\u0026gt;true... 10 !=15 // not equal to 10\u0026gt;5 // greater than 10\u0026lt;14 // less than 10 \u0026gt;= 10 // greater than or equal to 10 \u0026lt;= 10 // lees than or equal to 11.odd // it is odd 10.even // it is even 10.isInteger // it is integer 10.129.isFloat // it is float 1.odd.and(2.even) // both conditions 1.odd.or(1.even) // either condition "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/aperiodicsources/",
	"title": "Noise",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Noise Generators Aperiodic Sources: Noise\n/Aperiodic Sources: Noise. //LF \u0026#34;Low Frequency\u0026#34; Noise Generators. //arguments: frequency, mul, add { LFClipNoise.ar(MouseX.kr(200, 10000, 1), 0.125) }.scope(1); { LFPar.ar(LFClipNoise.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.scope(1, zoom:8); //Broad Spectrum Noise Generators //arguments: mul, add { ClipNoise.ar(0.2) }.scope(1); { WhiteNoise.ar(0.2) }.scope(1); { PinkNoise.ar(0.4) }.scope(1); { BrownNoise.ar(0.2) }.scope(1); { GrayNoise.ar(0.2) }.scope(1); // Impulse Noise Generators //Dust, Dust2 //arguments: density, mul, add  { Dust.ar(MouseX.kr(1,10000,1), 0.4) }.scope(1, zoom:4); //etc  //Chaotic Noise Generators //Crackle //arguments: chaosParam, mul, add  { Crackle.ar(MouseX.kr(1,2), 0.5) }.scope(1); "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/notation/",
	"title": "Notation",
	"tags": [],
	"description": "",
	"content": "chapter 1 Notation MIDI\nThe lowest note musicians use is C-1, which has the MIDI number 0. The number 12 = C0, 24 = C1, 36 = C2, 48 = C3, 60 = C4 (which is middle C on the piano, remember this one), and so on. A 440 is above middle C so it is 69.\n60, 62, 63, 60, 66\nFrequencies\nIt is the number of cycles (per second) of a periodic wave.\n0-20000Hz\n261.62, 293.66, 311.13, 261.62, 370;\nHexadecimal\n16 symbols\n(0-9, A-F)\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\n0000003C, 0000003E, 0000003F, 0000003C, 00000042\nBinary\n00111100, 00111110, 00111111, 00111100 01000010\nPitch class method\nC4, D4, Eb4, C4, F#4\n"
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/filters/",
	"title": "Filters",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Filters Filters in SuperCollider\n// Filters  //Low Pass, High Pass, Band Pass see more on Help //arguments: in, freq, mul, add  { LPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.scope(1); { HPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.scope(1); // Resonant Low Pass, High Pass, Band Pass //arguments: in, freq, rq, mul, add  { RLPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1); { RHPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.scope(1); // Resonz - resonant band pass filter with uniform amplitude //arguments: in, freq, rq, mul, add  // modulate frequency { Resonz.ar(WhiteNoise.ar(0.5), XLine.kr(1000,8000,10), 0.05) }.scope(1); //Ringz - ringing filter.  //arguments: in, frequency, ring time, mul, add  { Ringz.ar(Dust.ar(3, 0.3), 2000, 2) }.scope(1, zoom:4); //NonLinear Filters  // a signal with impulse noise. { Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1); // after applying median filter { Median.ar(3, Saw.ar(500, 0.1) + Dust2.ar(100, 0.9)) }.scope(1); // a signal with impulse noise. { Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.scope(1); // after applying slew rate limiter { Slew.ar(Saw.ar(500, 0.1) + Dust2.ar(100, 0.9),1000,1000) }.scope(1); //Formant Filter - Formlet - A filter whose impulse response is similar to a FOF grain.  { Formlet.ar(Impulse.ar(MouseX.kr(2,300,1), 0, 0.4), 800, 0.01, 0.1) }.scope(1, zoom:4); // Klank - resonant filter bank //arguments: `[ frequencies, amplitudes, ring times ], mul, add  { Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play; "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": "chapter 1 Glossary Mathematics\npremise a statement that is assumed to be true.\npolynomial function is an expression consisting of variables (also called indeterminates) and coefficients, that involves only the operations of addition, subtraction, multiplication, and non-negative integer exponents of variables (Wiki, see more here)\nPhysics\nfrequency the number of times that a wave, especially a light, sound, or radio wave, is produced within a particular period, especially one second.\namplitude the distance between the top and the bottom of a wave.\nwave superposition (systems theory) - superposition principle, see also Rolling motion,- is when a wave traversing the same space with other waves. (the sum of the amplitudes of any individual wave)\nComputing-SC-sound synthesis\nfunction lamda calculus\nSC Function a = { [100, 200, 300].choose };\nSC Event An Event is a SC Environment with a 'play' method. An Event specifies an action to be taken in response to a -play message.\nSC Pattern creates a Stream that iterates an array.\nSC Stream Streams represent sequences of values that are obtained one at a time.\nSC Pbind The pattern Pbind connects specific patterns with specific names. Consult its help page for details.\nwavetable is a table with the amplitude values of a signal\nMusic\nmotet Form of polyphonic vocal music (12th century)\n"
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/distortion/",
	"title": "Distortion",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Distorion // Distortion  { SinOsc.ar(300, 0, 0.2) }.scope(1); { SinOsc.ar(300, 0, 0.2).abs }.scope(1); { SinOsc.ar(300, 0, 0.2).max(0) }.scope(1); { SinOsc.ar(300, 0).squared * 0.2 }.scope(1); { SinOsc.ar(300, 0).cubed * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).distort * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).softclip * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).clip2(1) * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).fold2(1) * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.scope(1); { SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.scope(1); // waveshaping by phase modulating a 0 Hz sine oscillator  ( { var in; in = SinOsc.ar(300, 0, MouseX.kr(0.1,8pi,1)); SinOsc.ar(0, in, 0.2); // 0 Hz sine oscillator }.scope(1); ) //Shaper - input is used to look up a value in a table. //Chebyshev polynomials are typically used to fill the table.  s.sendMsg(\\b_alloc, 80, 1024); // allocate table // fill with chebyshevs s.listSendMsg([\\b_gen, 80, \\cheby, 7] ++ {1.0.rand2.squared}.dup(6)); { Shaper.ar(80, SinOsc.ar(600, 0, MouseX.kr(0,1))) * 0.3; }.scope(1); s.listSendMsg([\\b_gen, 80, \\cheby, 7] ++ {1.0.rand2.squared}.dup(6)); s.listSendMsg([\\b_gen, 80, \\cheby, 7] ++ {1.0.rand2.squared}.dup(6)); "
},
{
	"uri": "https://vasileios.github.io/dss/introduction/references/",
	"title": "References",
	"tags": [],
	"description": "",
	"content": "Chapter 1 References Cope, David. 2000. The Algorithmic Composer. Madison, Wis: A-R Editions.\nDean, Roger. and McLean, Alex (eds.) 2018. The Oxford Handbook of Algorithmic Music. Oxford University Press.\nFarnell, Andy. 2010. Designing Sound. Cambridge, Mass: The MIT Press.\nHoltzman, Steven. 1981. Generative Grammars for Music Composition. Computer Music Journal, Vol.5, No.1, pp. 51-64. The MIT Press.\nHusbands, Phil, Peter Copley, Alice Eldridge, and James Mandelis. 2007. ‘An Introduction to Evolutionary Computing for Musicians’. In Evolutionary Computer Music, 1–27. Springer, London. https://doi.org/10.1007/978-1-84628-600-1_1.\nΛώτης, Θ., Διαμαντόπουλος, Τ. 2015. Μουσική πληροφορική και μουσική με υπολογιστές. Εκδόσεις Κάλλιπος. [ηλεκτρ. βιβλ.] Αθήνα:Σύνδεσμος Ελληνικών Ακαδημαϊκών.\nMiranda, Eduardo R., and John Al Biles. 2007. Evolutionary Computer Music. Springer Science \u0026 Business Media.\nNierhaus, Gerhard. 2008. Algorithmic Composition: Paradigms of Automated Music Generation. 2009 edition. Wien ; New York: Springer.\nRoads, Curtis. 1996. The Computer Music Tutorial. Edition Unstated edition. Cambridge, Mass: The MIT Press.\nRoads, Curtis. 2004. Microsound. PAP/CDR edition. Cambridge, Mass.: The MIT Press.\nSethares, William A. 2004. Tuning, Timbre, Spectrum, Scale. 2nd edition. London: Springer.\nTolonen, T., Välimäki, V., and Karjalainen, M. 1998. Evaluation of Modern Sound Synthesis Methods. HUT.\nTrautmann, Lutz, and Rudolf Rabenstein. 2012. Digital Sound Synthesis by Physical Modeling Using the Functional Transformation Method. Springer Science \u0026 Business Media.\nSites  http://doc.sccode.org/ http://supercollider.github.io/tutorials/ http://chuck.cs.princeton.edu/doc/language/ http://chuck.cs.princeton.edu/doc/learn/ https://www.gnu.org/software/emacs/manual/ https://guides.github.com https://ccrma.stanford.edu/~blackrse/algorithm.html https://dictionary.cambridge.org/dictionary/english/algorithm http://digicult.it/digimag/issue-055/athanasius-kircher-arca-musarithmica-and https://www.youtube.com/watch?v=9Zdg6Ec4mVw https://www.npmjs.com/package/mozart-dice-game http://doc.sccode.org/Classes/Shaper.html http://doc.sccode.org/Classes/Wavetable.html http://doc.sccode.org/Browse.html#UGens%3EGranularSynthesis https://www.youtube.com/watch?v=MotG3XI2qSs http://chuck.cs.princeton.edu/release/ http://chuck.cs.princeton.edu/doc/learn/tutorial.html http://chuck.cs.princeton.edu/doc/program/ugen.html http://www.johncage.org/reunion/ https://www.youtube.com/watch?v=iPgwF3G5i4k https://getchip.com https://www.raspberrypi.org https://community.dur.ac.uk/nick.collins/teaching/supercollider/advanced/ machinelearningresources.scd https://composerprogrammer.com/researchml.html https://luuma.net/code https://www.cc.gatech.edu/~turk/bio_sim/articles/genetic_algorithm.pdf  "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/delays/",
	"title": "Delays",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Delays //Delays and Buffer UGens DelayN, DelayL, DelayC - simple delays N - no interpolation L - linear interpolation C - cubic interpolation arguments: in, maximum delay time, current delay time, mul, add ( // Dust randomly triggers Decay to create an exponential // decay envelope for the WhiteNoise input source { z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar); DelayN.ar(z, 0.1, 0.1, 1, z); // input is mixed with delay via the add input }.scope(1, zoom: 4) ) // CombN, CombL, CombC - feedback delays //arguments: in, maximum delay time, current delay time, echo decay time, mul, add  // used as an echo. { CombN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.scope(1, zoom:4); // Comb used as a resonator. The resonant fundamental is equal to // reciprocal of the delay time. { CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1); { CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1); { CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.scope(1); // with negative feedback: { CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1); { CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1); { CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.scope(1); { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/100, 1/100, 3) }.play; { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/200, 1/200, 3) }.play; { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/300, 1/300, 3) }.play; { CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/400, 1/400, 3) }.scope(1, zoom:4); //etc  //PlayBuf - buffer playback //arguments: numChannels, buffer number, rate, trigger, start pos, loop  // read sound b = Buffer.read(s, Platform.resourceDir +/+ \u0026#34;sounds/a11wlk01.wav\u0026#34;); { SinOsc.ar(800 + (700 * PlayBuf.ar(1,b, BufRateScale.kr(b), loop:1)),0,0.3) }.scope(1); // loop is true { PlayBuf.ar(1,b, BufRateScale.kr(b), loop:1) }.scope(1); "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/spectral/",
	"title": "Spectral",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Spectral FFT-PV_Ugens\nFFT, IFFT and the phase vocoder ugens. FFT calculates the spectrum of a sound, puts it into a buffer, and outputs a trigger each time the buffer is ready to process. The PV UGens process the spectrum when they receive the trigger. IFFT converts the spectrum back into sound.\n// alloc a buffer for the FFT b = Buffer.alloc(s,2048,1); // read a sound c = Buffer.read(s, Platform.resourceDir +/+ \u0026#34;sounds/a11wlk01.wav\u0026#34;); ( // do nothing { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); 0.5 * IFFT(chain); }.scope(1); ) ( // pass only magnitudes above a threshold { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagAbove(chain, MouseX.kr(0.1,512,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // pass only magnitudes below a threshold { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagBelow(chain, MouseX.kr(0.1,512,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // brick wall filter. { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_BrickWall(chain, MouseX.kr(-1,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // pass random frequencies. Mouse controls how many to pass. // trigger changes the frequencies periodically { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_RandComb(chain, MouseX.kr(0,1), Impulse.kr(0.4)); 0.5 * IFFT(chain); }.scope(1); ) ( // rectangular comb filter { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_RectComb(chain, 8, MouseY.kr(0,1), MouseX.kr(0,1)); 0.5 * IFFT(chain); }.scope(1); ) ( // freeze magnitudes { var in, chain; in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1); chain = FFT(b, in); chain = PV_MagFreeze(chain, LFPulse.kr(1, 0.75)); 0.5 * IFFT(chain); }.scope(1); ) "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/granularsynthesis/",
	"title": "Granular Synthesis",
	"tags": [],
	"description": "",
	"content": "chapter 2 SuperCollider Granular Synthesis //TGrains - granulation of a buffer //arguments: numChannels, trigger, buffer number, rate, center pos, dur, pan, amp, interpolation //see more about Granular synthesis on Help  // read sound b = Buffer.read(s, Platform.resourceDir +/+ \u0026#34;sounds/a11wlk01.wav\u0026#34;); ( { var trate, dur; trate = MouseY.kr(2,200,1); dur = 4 / trate; TGrains.ar(2, Impulse.ar(trate), b, 1, MouseX.kr(0,BufDur.kr(b)), dur, 0, 0.1, 2); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(8,120,1); dur = 12 / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) // 4 channels ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(8,120,1); dur = 12 / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(4, clk, b, 1, pos, dur, pan, 0.1); }.scope(4, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(8,120,1); dur = 4 / trate; clk = Dust.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = LinExp.kr(LFTri.kr(MouseY.kr(0.1,2,1)),-1,1,8,120); dur = 12 / trate; clk = Impulse.ar(trate); pos = MouseX.kr(0,BufDur.kr(b)); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = 12; dur = MouseY.kr(0.2,24,1) / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = 100; dur = 8 / trate; clk = Impulse.kr(trate); pos = Integrator.kr(BrownNoise.kr(0.001)); pan = WhiteNoise.kr(0.6); TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur, clk, pos, pan; trate = MouseY.kr(1,400,1); dur = 8 / trate; clk = Impulse.kr(trate); pos = MouseX.kr(0,BufDur.kr(b)); pan = WhiteNoise.kr(0.8); TGrains.ar(2, clk, b, 2 ** WhiteNoise.kr(2), pos, dur, pan, 0.1); }.scope(2, zoom: 4); ) ( { var trate, dur; trate = MouseY.kr(2,120,1); dur = 1.2 / trate; TGrains.ar(2, Impulse.ar(trate), b, (1.2 ** WhiteNoise.kr(3).round(1)), MouseX.kr(0,BufDur.kr(b)), dur, WhiteNoise.kr(0.6), 0.1); }.scope(2, zoom: 4); ) // free sound b.free; "
},
{
	"uri": "https://vasileios.github.io/dss/sc-examples/synthesistec/",
	"title": "Sound synthesis techniques",
	"tags": [],
	"description": "",
	"content": "chapter 2 Additive synthesis /* Sound Synthesis techniques BA 181902 Objective: create complex sounds using additive synthesis technique // Additive Synthesis a+b+c+d where a to d can be frequencies or any other object such as a waveform */ // firts boot the internal server and open Freqscope and Stethoscope  s = Server.internal; s.boot Stethoscope.new FreqScope.new //create harmonics of a 440Hz A note  {SinOsc.ar([440, 880, 880*3/2, 1600*4/3, 2000], 0, [0.6, 0.1, 0.09, 0.08, 0.09])}.play//or .scope //add frequencies using the Mix Ugen  {Mix.fill(10, {SinOsc.ar(440+460.rand, 0, 0.03)})}.play; //Add also different waveforms i.e sawtooth waveforms  {Mix.fill(10, {SinOsc.ar(440+440.rand, 0, 0.03)}, {Saw.ar(440+440.rand, 0.01)})}.play; // a more complex sound  {Mix.fill(10, {SinOsc.ar(440+640.rand, 0, 0.03)+Saw.ar(440+460.rand, 0.01)}, {Saw.ar(440+880.rand, 0.01)})}.play;  Physical Modeling Digital waveguide synthesis\n/* BA102002 Physical Modeling Digital waveguide synthesis: superposition of 2 waves (right going and left going waves) modal synthesis (resonant modes of vibration of acoustic systems)(vibrating systems) delay line (Using delays and filters to model the propagation of sound wave - geometry of the waveguide) mass-spring models (signals based on masses and springs) See more on: JA Laird., 2001. The Physical Modelling of Drums Using Digital Waveguides. University of Bristol */ /* Instruction: Envelope (sound behaviour - time domain), Impulse (trigger), NoiseGen (texture), CombL (delay line) */ ///WaveTables //Create a table with size 512 and the amplitudes which shape the waveform. Use Sine or Chebyshev polynomial function.  a = Wavetable.sineFill(512, 1.0/[1, 2, 3, 4, 5, 6]); a = Wavetable.chebyFill(513, [0, 0, 1]); a = Wavetable.chebyFill(513, [0.3, -0.8, 1.1]); a = Wavetable.sineFill(512, [0.5]); a = a.resamp1(256); a = a.as(Signal); a = a.asWavetable; // Server side s.boot; b = Buffer.loadCollection(s, a); x = b.play(loop: true); // ok sounds x.free; /// more on wavetables //load a wavetable and open the collection to a SoundFile w = SoundFile.openRead(\u0026#34;~/wavetables/WT01.aif\u0026#34;.standardizePath); // Create an array to load the data a = FloatArray.newClear(w.numFrames); w.readData(a); w.close; a.size; // resamp the table to have a pow of 2 (bigger to avoid aliassing) // in case of many diff samples choose a bigger pow of 2  a = a.resamp1(256); // Convert the array to a Signal a = a.as(Signal); a.size; // Convert it to a Wavetable a = a.asWavetable; a.size; //wavetable format is signal.size * 2  // load the collection into a buffer  b = Buffer.loadCollection(s, a); //play the buffer and loop x = b.play(loop: true); x.free; //use Osc interpolating wavetable oscillator. see also VOsc3 and more on Help-\u0026gt;UGens\u0026gt;Generators\u0026gt;Deterministic //Osc.ar(table, freq, phase, mul, add) x = { LPF.ar(Osc.ar(b, MouseX.kr(440, 880)), SampleRate.ir/2-1000) }.play;  s.freqscope x.free; //see Ball, TBall, Spring Ugens on Help //TBall //Example:1 // mouse x controls switch of level // mouse y controls gravity ( { var t, sf; sf = K2A.ar(MouseX.kr \u0026gt; 0.5) \u0026gt; 0; t = TBall.ar(sf, MouseY.kr(0.01, 1.0, 1), 0.01); Pan2.ar(Ringz.ar(t * 10, 1200, 0.1), MouseX.kr(-1,1)); }.play; ) //spring  ( { var inforce, outforce, freq, k, d; inforce = K2A.ar(MouseButton.kr(0,1,0)) \u0026gt; 0; k = MouseY.kr(0.1, 20, 1); d = MouseX.kr(0.00001, 0.1, 1); outforce = Spring.ar(inforce, k, d); freq = outforce * 400 + 500; // modulate frequency with the force  SinOsc.ar(freq, 0, 0.2) }.play; )  Wave shaping\n/* BA 182202 Waveshaping examples Objective: create a wavetable and shape the waveform */ s.boot; //Fill this buffer with a series of Chebyshev polynomials, see more on Help-\u0026gt;Buffer b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])}); ( { Shaper.ar( b, SinOsc.ar(300, 0, Line.kr(0,1,6)+Saw.ar(304, Line.kr(0, 1, 6))), 0.5 ) }.scope; ) b.free; //another example with sine wave series //Fill this buffer with a series of sine wave partials using specified frequencies, amplitudes, and initial phases. b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg([1,0,1,1,0,1])}); //see also sine2 and 3  ( { Shaper.ar( b, SinOsc.ar(300+305.rand, 0, LFNoise2.kr(0+0.15)+Saw.ar(304+30.7.rand, LFNoise2.kr(0.15))), 0.5 ) }.scope; ) b.free; //another example  b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])}); //check also with other tables. //Combine tables //b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])}); //b = Buffer.alloc(s, 512, 1, { |buf| buf.sine1Msg([1,0,1,1,0,1])});  ( { Shaper.ar( b, SinOsc.ar(300+305.rand, 0, LFNoise2.kr(0+0.15.rand)+Saw.ar(304+307.rand, LFNoise2.kr(0.15.rand)))+PinkNoise.ar(0.1.rand), 0.5 ) }.scope; ) b.free;  Creating textures with wavetables\n/* BA 182202 Sound Textures examples Objective: Experiment with table oscilators to create sound textures */ // COsc wavetable example 1:  ( b = Buffer.alloc(s, 512, 1, {| buf | buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])}); { LPF.ar(COsc.ar(b.bufnum, [200.rand.postln, 1000.rand], 0.7, 0.25)*Saw.ar(440+444.rand, WhiteNoise.kr(0.7)), 4000) }.play; )  Modulation synthesis /* Modulation synthesis Obective: modulate the frequency,the phase and the amplitude of a simple waveform using other waveforms as the modulators */ /*From 2009 Collins et al. Modulation Synthesis tutorial //Use MouseX and MouseY to control the modulation //Ring Modulation A straight multiplication of two signals. carrier * modulator */ { //2009 Collins et al. var carrier, modulator, carrfreq, modfreq; carrfreq= MouseX.kr(440,5000,\u0026#39;exponential\u0026#39;); modfreq= MouseY.kr(1,5000,\u0026#39;exponential\u0026#39;); carrier= SinOsc.ar(carrfreq,0,0.5); modulator= SinOsc.ar(modfreq,0,0.5); carrier*modulator; }.scope /* AM synthesis The modulation is Unipolar means always possitive (0, 1) SinOsc.ar(440, 0, 0.5) (-0.5, 0.5) bipolar SinOsc.ar(440, 0, 0.5, 0.5) (0, 1) unipolar */ ( { //2009 Collins et al. var carrier, modulator, carrfreq, modfreq; carrfreq= MouseX.kr(440,5000,\u0026#39;exponential\u0026#39;); modfreq= MouseY.kr(1,5000,\u0026#39;exponential\u0026#39;); carrier= SinOsc.ar(carrfreq,0,0.5); modulator= SinOsc.ar(modfreq,0,0.25, 0.25); carrier*modulator; }.scope ) // another example, One possitive one negative  {SinOsc.ar(440, 0, SinOsc.ar(0.5), SinOsc.ar(0.5))}.scope // both possitive and negative  {SinOsc.ar(440, 0, SinOsc.ar(0.25), 0.25)}.scope // adding a MouseX variable to control the modulation of the amplitude  { var carrier, modulator, carrfreq, modfreq, modamp; carrfreq= MouseX.kr(440,5000,\u0026#39;exponential\u0026#39;); modfreq= MouseY.kr(1,5000,\u0026#39;exponential\u0026#39;); modamp = MouseX.kr(0.1, 1, \u0026#39;exponential\u0026#39;); carrier= SinOsc.ar(carrfreq,0,0.5); modulator= SinOsc.ar(modfreq,0,SinOsc.ar(modamp), SinOsc.ar(modamp)); carrier*modulator; }.scope /* Fm synthesis (frequency modulation) is a technique of changing the timbre of a waveform by modulating its frequency. */ ( var synth; synth= {| carrfreq=440, modfreq=1, moddepth=0.01| SinOsc.ar(carrfreq + MouseX.kr(moddepth, 5000, \u0026#39;exponential\u0026#39;)*SinOsc.ar(MouseY.kr(modfreq, 10000, \u0026#39;exponential\u0026#39;)),0,0.25) }.scope; ) // control the carrfreq as well  ( var synth; synth= {| carrfreq=440, modfreq=1, moddepth=0.01| SinOsc.ar(MouseX.kr(carrfreq, 10000, \u0026#39;exponential\u0026#39;) + MouseX.kr(moddepth, 5000, \u0026#39;exponential\u0026#39;)*SinOsc.ar(MouseY.kr(modfreq, 10000, \u0026#39;exponential\u0026#39;)),0,0.25) }.scope; ) //Create a window with sliders to control the frequency modulation (Collins 2009 et al. sc_tutorials)  ( var w, carrfreqslider, modfreqslider, moddepthslider, synth; w=Window(\u0026#34;frequency modulation\u0026#34;, Rect(100, 400, 400, 300)); w.view.decorator = FlowLayout(w.view.bounds); synth= {arg carrfreq=440, modfreq=1, moddepth=0.01; SinOsc.ar(carrfreq + (moddepth*SinOsc.ar(modfreq)),0,0.25) }.scope; carrfreqslider= EZSlider(w, 300@50, \u0026#34;carrfreq\u0026#34;, ControlSpec(20, 5000, \u0026#39;exponential\u0026#39;, 10, 440), {|ez| synth.set(\\carrfreq, ez.value)}); w.view.decorator.nextLine; modfreqslider= EZSlider(w, 300@50, \u0026#34;modfreq\u0026#34;, ControlSpec(1, 5000, \u0026#39;exponential\u0026#39;, 1, 1), {|ez| synth.set(\\modfreq, ez.value)}); w.view.decorator.nextLine; moddepthslider= EZSlider(w, 300@50, \u0026#34;moddepth\u0026#34;, ControlSpec(0.01, 5000, \u0026#39;exponential\u0026#39;, 0.01, 0.01), {|ez| synth.set(\\moddepth, ez.value)}); w.front; ) //Phase Modulation ( { //2009 Collins et al. var modf, ind; modf= MouseX.kr(1,440, \u0026#39;exponential\u0026#39;); ind=MouseY.kr(0.0,10.0); SinOsc.ar(440, SinOsc.ar(modf,0,modf*ind),0.25) }.scope ) "
},
{
	"uri": "https://vasileios.github.io/dss/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://vasileios.github.io/dss/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]